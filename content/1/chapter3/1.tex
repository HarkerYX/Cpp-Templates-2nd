In contrast to the sample implementations of a stack in previous chapters, you can also implement a stack by using a fixed-size array for the elements. An advantage of this method is that the memory management overhead, whether performed by you or by a standard container, is avoided. However, determining the best size for such a stack can be challenging. The smaller the size you specify, the more likely it is that the stack will get full. The larger the size you specify, the more likely it is that memory will be reserved unnecessarily. A good solution is to let the user of the stack specify the size of the array as the maximum size needed for stack elements.

To do this, define the size as a template parameter:

\noindent
\textit{basics/stacknontype.hpp}
\begin{lstlisting}[style=styleCXX]
#include <array>
#include <cassert>

template<typename T, std::size_t Maxsize>
class Stack {
private:
	std::array<T,Maxsize> elems; // elements
	std::size_t numElems; // current number of elements
public:
	Stack(); // constructor
	void push(T const& elem); // push element
	void pop(); // pop element
	T const& top() const; // return top element
	bool empty() const { // return whether the stack is empty
		return numElems == 0;
	}
	std::size_t size() const { // return current number of elements
		return numElems;
	}
};

template<typename T, std::size_t Maxsize>
Stack<T,Maxsize>::Stack ()
: numElems(0) // start with no elements
{
	// nothing else to do
}

template<typename T, std::size_t Maxsize>
void Stack<T,Maxsize>::push (T const& elem)
{
	assert(numElems < Maxsize);
	elems[numElems] = elem; // append element
	++numElems; // increment number of elements
}

template<typename T, std::size_t Maxsize>
void Stack<T,Maxsize>::pop ()
{
	assert(!elems.empty());
	--numElems; // decrement number of elements
}

template<typename T, std::size_t Maxsize>
T const& Stack<T,Maxsize>::top () const
{
	assert(!elems.empty());
	return elems[numElems-1]; // return last element
}
\end{lstlisting}

The new second template parameter, Maxsize, is of type int. It specifies the size of the internal array of stack elements:

\begin{lstlisting}[style=styleCXX]
template<typename T, std::size_t Maxsize>
class Stack {
	private:
	std::array<T,Maxsize> elems; // elements
	...
};
\end{lstlisting}

In addition, it is used in push() to check whether the stack is full:

\begin{lstlisting}[style=styleCXX]
template<typename T, std::size_t Maxsize>
void Stack<T,Maxsize>::push (T const& elem)
{
	assert(numElems < Maxsize);
	elems[numElems] = elem; // append element
	++numElems; // increment number of elements
}
\end{lstlisting}

To use this class template you have to specify both the element type and the maximum size:

\noindent
\textit{basics/stacknontype.cpp}
\begin{lstlisting}[style=styleCXX]
#include "stacknontype.hpp"
#include <iostream>
#include <string>

int main()
{
	Stack<int,20> int20Stack; // stack of up to 20 ints
	Stack<int,40> int40Stack; // stack of up to 40 ints
	Stack<std::string,40> stringStack; // stack of up to 40 strings
	
	// manipulate stack of up to 20 ints
	int20Stack.push(7);
	std::cout << int20Stack.top() << '\n';
	int20Stack.pop();
	
	// manipulate stack of up to 40 strings
	stringStack.push("hello");
	std::cout << stringStack.top() << '\n';
	stringStack.pop();
}
\end{lstlisting}

Note that each template instantiation is its own type. Thus, int20Stack and int40Stack are two different types, and no implicit or explicit type conversion between them is defined. Thus, one cannot be used instead of the other, and you cannot assign one to the other.

Again, default arguments for the template parameters can be specified:

\begin{lstlisting}[style=styleCXX]
template<typename T = int, std::size_t Maxsize = 100>
class Stack {
	...
};
\end{lstlisting}

However, from a perspective of good design, this may not be appropriate in this example. Default arguments should be intuitively correct. But neither type int nor a maximum size of 100 seems intuitive for a general stack type. Thus, it is better when the programmer has to specify both values explicitly so that these two attributes are always documented during a declaration.





























