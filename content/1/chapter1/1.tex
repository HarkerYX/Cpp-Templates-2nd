

函数模板提供了适用于不同数据类型的行为，代表的是一组函数。除了某些信息未明确指定外，看起来就和普通函数一样。这些未指定的信息就是参数化信息。

\subsubsubsection{1.1.1\hspace{0.2cm}定义模板}

下面就是一个函数模板，返回两个数的最大值：

\noindent
\textit{basics/max1.hpp}
\begin{lstlisting}[style=styleCXX]
template<typename T>
T max (T a, T b)
{
	// if b < a then yield a else yield b
	return b < a ? a : b;
}
\end{lstlisting}

这个模板定义指定了一个函数组，它返回两个值的最大值，a和b作为函数的参数。

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm}根据[StepanovNotes]，\texttt{max()}模板有意地返回\texttt{b < a ? a: b}，而不是\texttt{a < b ? b: a}，是为了确保函数行为的正确性。
\end{tcolorbox}

形参的类型为\texttt{模板参数T}。本例中可以看到，模板参数必须使用以下形式的进行声明:

\begin{lstlisting}[style=styleCXX]
template<逗号分割的模板参数>
\end{lstlisting}

示例中，参数列表是\texttt{typename T}。注意\texttt{<}和\texttt{>}尖括号。关键字\texttt{typename}引入了一个类型参数。这是C++程序中最常见的模板参数类型，也可以使用其他参数，会在后面进行讨论(参见第3章)。

类型参数是\texttt{T}，也可以使用其他标识符作为参数名，不过T是惯例罢了。类型参数表示在调用函数时才确定的类型，可以使用任意支持模板使用操作的类型(基本类型、类等)。因为a和b使用小于操作符进行比较，所以类型\texttt{T}必须支持操作符\texttt{<}。\texttt{max()}的定义可能不太明显，类型T的值必须可复制，以便返回。

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm}C++17之前，类型\texttt{T}也必须可复制才能传递参数。C++17以后，即使复制构造函数和移动构造函数都无效，也可以传递临时变量(右值，参见附录B)。
\end{tcolorbox}

因为一些历史原因，还可以使用关键字\texttt{class}来定义类型参数。关键字\texttt{typename}在C++98标准中出现得相对较晚，所以在此之前，关键字\texttt{class}是引入类型参数的唯一方法，现在这种方法仍然有效。因此，模板\texttt{max()}可以等价地定义为:

\begin{lstlisting}[style=styleCXX]
template<class T>
T max (T a, T b)
{
	return b < a ? a : b;
}
\end{lstlisting}

这里没有语义上的区别，即使使用\texttt{class}，模板参数也可以使用任意类型。但因为这样使用\texttt{class}可能会引起误解(不仅是类可以替换为\texttt{T})，所以应该更倾向于中使用\texttt{typename}。但与类声明不同，在声明类型参数时，不能使用关键字\texttt{struct}来代替\texttt{typename}。

\subsubsubsection{1.1.2\hspace{0.2cm}使用模板}

下面的展示了如何使用函数模板\texttt{max()}:

\noindent
\textit{basics/max1.cpp}
\begin{lstlisting}[style=styleCXX]
#include "max1.hpp"
#include <iostream>
#include <string>

int main()
{
	int i = 42;
	std::cout << "max(7,i): " << ::max(7,i) << '\n';
	
	double f1 = 3.4;
	double f2 = -6.7;
	std::cout << "max(f1,f2): " << ::max(f1,f2) << '\n';
	
	std::string s1 = "mathematics";
	std::string s2 = "math";
	std::cout << "max(s1,s2): " << ::max(s1,s2) << '\n';
}
\end{lstlisting}

这里，\texttt{max()}调用了三次:整型，双精度浮点类型，\texttt{std::string}。输出如下:

\begin{tcblisting}{commandshell={}}
max(7,i): 42
max(f1,f2): 3.4
max(s1,s2): mathematics
\end{tcblisting}

代码中，对\texttt{max()}的使用都用\texttt{::}限定。这是为了确保在全局命名空间中找到\texttt{max()}模板。在标准库中有一个\texttt{std::max()}，在某些情况下可以使用，但在这里可能会产生歧义。

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm}在命名空间\texttt{std}中定义了一个参数类型(例如\texttt{std::string})，根据C++的查找规则，\texttt{std}中的\texttt{max()}模板函数和全局模板函数都会被找到(参见附录C)。
\end{tcolorbox}

模板不会编译成处理任意类型的实体。相反，对于模板所使用的每个类型，会根据模板中生成不同的实体。

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm}“一体多用”的方案想想是可以的，但不会在实践中使用(运行时效率较低)。所有语言规则都基于这样一个原则:对于不同的模板参数，会生成不同的实体。
\end{tcolorbox}

因此，\texttt{max()}对这三种类型进行了分别编译。例如，\texttt{max()}的第一次调用

\begin{lstlisting}[style=styleCXX]
int i = 42;
... max(7,i) ...
\end{lstlisting}

使用int作为模板形参T的函数模板。因此，等同于调用的如下函数:

\begin{lstlisting}[style=styleCXX]
int max (int a, int b)
{
	return b < a ? a : b;
}
\end{lstlisting}

用具体类型替换模板参数的过程称为实例化，会产生一个模板实例。

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm}面向对象编程中，术语\texttt{实例(instance)}和\texttt{实例化(instantiate)}用于不同的上下文——类的具体对象。然而，由于本书针对模板，仅用来这两个术语表示对模板的“使用”，除非另有说明。
\end{tcolorbox}

注意，使用函数模板就可以进行实例化，开发者无需单独实例化。

类似地，\texttt{max()}的其他调用实例化了\texttt{double}和\texttt{std::string}的\texttt{max}模板:

\begin{lstlisting}[style=styleCXX]
double max (double, double);
std::string max (std::string, std::string);
\end{lstlisting}

如果结果代码有效，\texttt{void}是有效的模板参数。例如:

\begin{lstlisting}[style=styleCXX]
template<typename T>
T foo(T*)
{
}

void* vp = nullptr;
foo(vp); // OK: deduces void foo(void*)
\end{lstlisting}

\subsubsubsection{1.1.3\hspace{0.2cm}两阶段翻译}

若为为不支持使用操作的类型实例化模板，将导致编译时错误。例如:

\begin{lstlisting}[style=styleCXX]
std::complex<float> c1, c2; // doesn’t provide operator <
...
::max(c1,c2); // ERROR at compile time
\end{lstlisting}

因此，模板“编译”分为两个阶段:

\begin{enumerate}
\item 
若在定义时不进行实例化，则会检查模板代码的正确性，而忽略模板参数。这包括:
\begin{itemize}
\item[-] 
现语法错误，比如:缺少分号。

\item[-]
使用未知名称的模板参数(类型名、函数名……)。

\item[-]
检查(不依赖于模板参数的)静态断言。
\end{itemize}

\item 
实例化时，再次检查模板代码，确保生成的代码皆有效。特别是所有依赖于模板参数的部分，都会进行重复检查。
\end{enumerate}

例如：

\begin{lstlisting}[style=styleCXX]
template<typename T>
void foo(T t)
{
	undeclared(); // 若undeclared()未知，则在第一阶段编译时报错
	undeclared(t); // 若undeclared(T)未知，则在第二阶段编译时报错
	static_assert(sizeof(int) > 10, // always fails if sizeof(int)<=10
				  "int too small");
	static_assert(sizeof(T) > 10, // fails if instantiated for T with size <=10
	              "T too small");
}
\end{lstlisting}

检查两次名称的情况称为两阶段查找，在第14.3.1节会进行详细讨论。

注意，有些编译器不在第一阶段编译时进行完全的检查。

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm}例如，一些版本的Visual C++编译器(如Visual Studio 2013和2015)允许模板参数使用未声明名称，甚至允许一些语法缺陷(如缺少分号)。
\end{tcolorbox}

因此，在模板代码第一次实例化前，可能不会看到存在的问题。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{编译和连接}

两阶段翻译在实际处理模板时，会有一个问题:当以数模板实例化的方式使用函数模板时，编译器(在某些时候)需要查看该模板的定义。当一个函数的声明足以编译并连接通过时，就打破了普通函数的编译和链接方式。第9章讨论了处理这个问题的方法。现在，我们使用最简单的方法:仅在头文件中实现每个模板。








