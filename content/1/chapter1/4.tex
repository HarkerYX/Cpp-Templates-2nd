You can also define default values for template parameters. These values are called default template arguments and can be used with any kind of template.

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm}Prior to C++11, default template arguments were only permitted in class templates, due to a historical glitch in the development of function templates.
\end{tcolorbox}

They may even refer to previous template parameters.

For example, if you want to combine the approaches to define the return type with the ability to have multiple parameter types (as discussed in the section before), you can introduce a template parameter RT for the return type with the common type of the two arguments as default. Again, we have multiple options:


\begin{enumerate}
\item 
We can use operator?: directly. However, because we have to apply operator?: before the call parameters a and b are declared, we can only use their types:

\noindent
\textit{asics/maxdefault1.hpp}
\begin{lstlisting}[style=styleCXX]
#include <type_traits>

template<typename T1, typename T2,
typename RT = std::decay_t<decltype(true ? T1() : T2())>>
RT max (T1 a, T2 b)
{
	return b < a ? a : b;
}
\end{lstlisting}

Note again the usage of std::decay\_t<> to ensure that no reference can be returned.

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm}Again, in C++11 you had to use typename std::decay<...>::type instead of std::decay\_t<...> (see Section 2.8).
\end{tcolorbox}

Note also that this implementation requires that we are able to call default constructors for the passed types. There is another solution, using std::declval, which, however, makes the declaration even more complicated. See Section 11.2.3 for an example.

\item
We can also use the std::common\_type<> type trait to specify the default value for the return type: 

\noindent
\textit{asics/maxdefault3.hpp}
\begin{lstlisting}[style=styleCXX]
#include <type_traits>

template<typename T1, typename T2,
typename RT = std::common_type_t<T1,T2>>
RT max (T1 a, T2 b)
{
	return b < a ? a : b;
}
\end{lstlisting}

Again, note that std::common\_type<> decays so that the return value can’t become a reference.
\end{enumerate}

In all cases, as a caller, you can now use the default value for the return type:

\begin{lstlisting}[style=styleCXX]
auto a = ::max(4, 7.2);
\end{lstlisting}

or specify the return type after all other argument types explicitly:

\begin{lstlisting}[style=styleCXX]
auto b = ::max<double,int,long double>(7.2, 4);
\end{lstlisting}

However, again we have the problem that we have to specify three types to be able to specify the return type only. Instead, we would need the ability to have the return type as the first template parameter, while still being able to deduce it from the argument types. In principle, it is possible to have default arguments for leading function template parameters even if parameters without default arguments follow:

\begin{lstlisting}[style=styleCXX]
template<typename RT = long, typename T1, typename T2>
RT max (T1 a, T2 b)
{
	return b < a ? a : b;
}
\end{lstlisting}

With this definition, for example, you can call:

\begin{lstlisting}[style=styleCXX]
int i;
long l;
...
max(i, l); // returns long (default argument of template parameter for return type)
max<int>(4, 42); // returns int as explicitly requested
\end{lstlisting}

However, this approach only makes sense, if there is a “natural” default for a template parameter. Here, we need the default argument for the template parameter to depend from previous template parameters. In principle, this is possible as we discuss in Section 26.5.1 on page 621, but the technique depends on type traits and complicates the definition.

For all these reasons, the best and easiest solution is to let the compiler deduce the return type as proposed in Section 1.3.2.
