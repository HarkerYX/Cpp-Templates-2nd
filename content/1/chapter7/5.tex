

For return values, you can also decide between returning by value or by reference. However, returning references is potentially a source of trouble, because you refer to something that is out of your control. There are a few cases where returning references is common programming practice:

\begin{itemize}
\item 
Returning elements of containers or strings (e.g., by operator[] or front())

\item 
Granting write access to class members

\item 
Returning objects for chained calls (operator<< and operator>> for streams and operator= for class objects in general)
\end{itemize}

In addition, it is common to grant read access to members by returning const references.

Note that all these cases may cause trouble if used improperly. For example:

\begin{lstlisting}[style=styleCXX]
std::string* s = new std::string("whatever");
auto& c = (*s)[0];
delete s;
std::cout << c; // run-time ERROR
\end{lstlisting}

Here, we obtained a reference to an element of a string, but by the time we use that reference, the underlying string no longer exists (i.e., we created a dangling reference), and we have undefined behavior. This example is somewhat contrived (the experienced programmer is likely to notice the problem right away), but things easily become less obvious. For example:

\begin{lstlisting}[style=styleCXX]
auto s = std::make_shared<std::string>("whatever");
auto& c = (*s)[0];
s.reset();
std::cout << c; // run-time ERROR
\end{lstlisting}

We should therefore ensure that function templates return their result by value. However, as discussed in this chapter, using a template parameter T is no guarantee that it is not a reference, because T might sometimes implicitly be deduced as a reference:

\begin{lstlisting}[style=styleCXX]
template<typename T>
T retR(T&& p) // p is a forwarding reference
{
	return T{...}; // OOPS: returns by reference when called for lvalues
}
\end{lstlisting}

Even when T is a template parameter deduced from a call-by-value call, it might become a reference type when explicitly specifying the template parameter to be a reference:

\begin{lstlisting}[style=styleCXX]
template<typename T>
T retV(T p) // Note: T might become a reference
{
	return T{...}; // OOPS: returns a reference if T is a reference
}

int x;
retV<int&>(x); // retT() instantiated for T as int&
\end{lstlisting}

To be safe, you have two options:

\begin{itemize}
\item 
Use the type trait std::remove\_reference<> (see Section D.4) to convert type T to a nonreference:

\begin{lstlisting}[style=styleCXX]
template<typename T>
typename std::remove_reference<T>::type retV(T p)
{
	return T{...}; // always returns by value
}
\end{lstlisting}

Other traits, such as std::decay<> (see Section D.4), may also be useful here because they also implicitly remove references.

\item 
Let the compiler deduce the return type by just declaring the return type to be auto (since C++14; see Section 1.3.2), because auto always decays:

\begin{lstlisting}[style=styleCXX]
template<typename T>
auto retV(T p) // by-value return type deduced by compiler
{
	return T{...}; // always returns by value
}
\end{lstlisting}

\end{itemize}


















