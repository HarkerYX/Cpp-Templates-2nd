

Aggregate classes (classes/structs with no user-provided, explicit, or inherited constructors, no private or protected nonstatic data members, no virtual functions, and no virtual, private, or protected base classes) can also be templates. For example:

\begin{lstlisting}[style=styleCXX]
template<typename T>
struct ValueWithComment {
	T value;
	std::string comment;
};
\end{lstlisting}

defines an aggregate parameterized for the type of the value val it holds. You can declare objects as for any other class template and still use it as aggregate:

\begin{lstlisting}[style=styleCXX]
ValueWithComment<int> vc;
vc.value = 42;
vc.comment = "initial value";
\end{lstlisting}

Since C++17, you can even define deduction guides for aggregate class templates:

\begin{lstlisting}[style=styleCXX]
ValueWithComment(char const*, char const*)
	-> ValueWithComment<std::string>;
ValueWithComment vc2 = {"hello", "initial value"};
\end{lstlisting}

Without the deduction guide, the initialization would not be possible, because ValueWithComment has no constructor to perform the deduction against.

The standard library class std::array<> is also an aggregate, parameterized for both the element type and the size. The C++17 standard library also defines a deduction guide for it, which we discuss in Section 4.4.4.
