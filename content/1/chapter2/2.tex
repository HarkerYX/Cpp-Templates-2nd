To use an object of a class template, until C++17 you must always specify the template arguments explicitly.

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm}C++17 introduced class argument template deduction, which allows skipping template arguments if they can
be derived from the constructor. This will be discussed in Section 2.9.
\end{tcolorbox}

The following example shows how to use the class template Stack<>:

\noindent
\textit{basics/stack1test.cpp}
\begin{lstlisting}[style=styleCXX]
#include "stack1.hpp"
#include <iostream>
#include <string>
int main()
{
	Stack<int> intStack; // stack of ints
	Stack<std::string> stringStack; // stack of strings
	
	// manipulate int stack
	intStack.push(7);
	std::cout << intStack.top() << '\n';
	
	// manipulate string stack
	stringStack.push("hello");
	std::cout << stringStack.top() << '\n';
	stringStack.pop();
}
\end{lstlisting}

By declaring type Stack<int>, int is used as type T inside the class template. Thus, intStack is created as an object that uses a vector of ints as elements and, for all member functions that are called, code for this type is instantiated. Similarly, by declaring and using Stack<std::string>, an object that uses a vector of strings as elements is created, and for all member functions that are called, code for this type is instantiated.

Note that code is instantiated only for template (member) functions that are called. For class templates, member functions are instantiated only if they are used. This, of course, saves time and space and allows use of class templates only partially, which we will discuss in Section 2.3.

In this example, the default constructor, push(), and top() are instantiated for both int and strings. However, pop() is instantiated only for strings. If a class template has static members, these are also instantiated once for each type for which the class template is used.

An instantiated class template’s type can be used just like any other type. You can qualify it with const or volatile or derive array and reference types from it. You can also use it as part of a type definition with typedef or using (see Section 2.8 for details about type definitions) or use it as a type parameter when building another template type. For example:

\begin{lstlisting}[style=styleCXX]
void foo(Stack<int> const& s) // parameter s is int stack
{
	using IntStack = Stack<int>; // IntStack is another name for Stack<int>
	Stack<int> istack[10]; // istack is array of 10 int stacks
	IntStack istack2[10]; // istack2 is also an array of 10 int stacks (same type)
	...
}
\end{lstlisting}

Template arguments may be any type, such as pointers to floats or even stacks of ints:

\begin{lstlisting}[style=styleCXX]
Stack<float*> floatPtrStack; // stack of float pointers
Stack<Stack<int>> intStackStack; // stack of stack of ints
\end{lstlisting}

The only requirement is that any operation that is called is possible according to this type.

Note that before C++11 you had to put whitespace between the two closing template brackets:

\begin{lstlisting}[style=styleCXX]
Stack<Stack<int> > intStackStack; // OK with all C++ versions
\end{lstlisting}

If you didn’t do this, you were using operator >>, which resulted in a syntax error:

\begin{lstlisting}[style=styleCXX]
Stack<Stack<int>> intStackStack; // ERROR before C++11
\end{lstlisting}

The reason for the old behavior was that it helped the first pass of a C++ compiler to tokenize the source code independent of the semantics of the code. However, because the missing space was a typical bug, which required corresponding error messages, the semantics of the code more and more had to get taken into account anyway. So, with C++11 the rule to put a space between two closing template brackets was removed with the “angle bracket hack” (see Section 13.3.1 for details).





















