
类模板通常对其实例化的模板参数使用多个操作(包括构造和分解)。这可能会造成这样的情况:这些模板参数必须为类模板的所有成员函数，提供所有必要的操作。但事实并非如此:模板参数只需要提供所需的必要操作(而不是可能需要)。

例如，类\texttt{Stack<>}提供成员函数\texttt{printOn()}打印堆栈中的全部内容，并对每个元素使用操作符\texttt{<<}:

\begin{lstlisting}[style=styleCXX]
template<typename T>
class Stack {
	...
	void printOn() (std::ostream& strm) const {
		for (T const& elem : elems) {
			strm << elem << ' '; // 对每个元素使用<<
		}
	}
};
\end{lstlisting}

对于没有定义操作符\texttt{<<}的类型，仍然可以使用这个类:

\begin{lstlisting}[style=styleCXX]
Stack<std::pair<int,int>> ps; // 注意: std::pair<>不支持<<
ps.push({4, 5}); // OK
ps.push({6, 7}); // OK
std::cout << ps.top().first << '\n'; // OK
std::cout << ps.top().second << '\n'; // OK
\end{lstlisting}

只在使用\texttt{printOn()}时代码才会出错，因为它不能实例化对特定元素类型的操作符\texttt{<<}:

\begin{lstlisting}[style=styleCXX]
ps.printOn(std::cout); // ERROR: 元素类型不支持操作符<<
\end{lstlisting}

\subsubsubsection{2.3.1\hspace{0.2cm}概念}

This raises the question: How do we know which operations are required for a template to be able to get instantiated? The term concept is often used to denote a set of constraints that is repeatedly required in a template library. For example, the C++ standard library relies on such concepts as random access iterator and default constructible.

Currently (i.e., as of C++17), concepts can more or less only be expressed in the documentation (e.g., code comments). This can become a significant problem because failures to follow constraints can lead to terrible error messages (see Section 9.4).

For years, there have also been approaches and trials to support the definition and validation of concepts as a language feature. However, up to C++17 no such approach was standardized yet.

Since C++11, you can at least check for some basic constraints by using the static\_assert keyword and some predefined type traits. For example:

\begin{lstlisting}[style=styleCXX]
template<typename T>
class C
{
	static_assert(std::is_default_constructible<T>::value,
	"Class C requires default-constructible elements");
	...
};
\end{lstlisting}

Without this assertion the compilation will still fail, if the default constructor is required. However, the error message then might contain the entire template instantiation history from the initial cause of the instantiation down to the actual template definition in which the error was detected (see Section 9.4).

However, more complicated code is necessary to check, for example, objects of type T provide a specific member function or that they can be compared using operator <. See Section 19.6.3 for a detailed example of such code. 

See Appendix E for a detailed discussion of concepts for C++.















