Even when using alias templates, the enable\_if syntax is pretty clumsy, because it uses a workaround: To get the desired effect, we add an additional template parameter and “abuse” that parameter to provide a specific requirement for the function template to be available at all. Code like this is hard to read and makes the rest of the function template hard to understand.

In principle, we just need a language feature that allows us to formulate requirements or constraints for a function in a way that causes the function to be ignored if the requirements/constraints are not met.

This is an application of the long-awaited language feature concepts, which allows us to formulate requirements/conditions for templates with its own simple syntax. Unfortunately, although long discussed, concepts still did not become part of the C++17 standard. Some compilers provide experimental support for such a feature, however, and concepts will likely become part of the next standard after C++17.

With concepts, as their use is proposed, we simply have to write the following:

\begin{lstlisting}[style=styleCXX]
template<typename STR>
requires std::is_convertible_v<STR,std::string>
Person(STR&& n) : name(std::forward<STR>(n)) {
	...
}
\end{lstlisting}

We can even specify the requirement as a general concept

\begin{lstlisting}[style=styleCXX]
template<typename T>
concept ConvertibleToString = std::is_convertible_v<T,std::string>;
\end{lstlisting}

and formulate this concept as a requirement:

\begin{lstlisting}[style=styleCXX]
template<typename STR>
requires ConvertibleToString<STR>
Person(STR&& n) : name(std::forward<STR>(n)) {
	...
}
\end{lstlisting}

This also can be formulated as follows:

\begin{lstlisting}[style=styleCXX]
template<ConvertibleToString STR>
Person(STR&& n) : name(std::forward<STR>(n)) {
	...
}
\end{lstlisting}

See Appendix E for a detailed discussion of concepts for C++.




















