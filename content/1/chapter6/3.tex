Since C++11, the C++ standard library provides a helper template std::enable\_if<> to ignore function templates under certain compile-time conditions.

For example, if a function template foo<>() is defined as follows:

\begin{lstlisting}[style=styleCXX]
template<typename T>
typename std::enable_if<(sizeof(T) > 4)>::type
foo() {
}
\end{lstlisting}

this definition of foo<>() is ignored if sizeof(T) > 4 yields false.

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm}Donâ€™t forget to place the condition into parentheses, because otherwise the > in the condition would end the template argument list.
\end{tcolorbox}

If sizeof(T) > 4 yields true, the function template instance expands to

\begin{lstlisting}[style=styleCXX]
void foo() {
}
\end{lstlisting}

That is, std::enable\_if<> is a type trait that evaluates a given compile-time expression passed as its (first) template argument and behaves as follows:

\begin{itemize}
\item 
If the expression yields true, its type member type yields a type:

\begin{itemize}
\item[-]
The type is void if no second template argument is passed.
	
\item[-]
Otherwise, the type is the second template argument type.
\end{itemize}

\item 
If the expression yields false, the member type is not defined. Due to a template feature called SFINAE (substitution failure is not an error), which is introduced later (see Section 8.4), this has the effect that the function template with the enable\_if expression is ignored.
\end{itemize}

As for all type traits yielding a type since C++14, there is a corresponding alias template std::enable\_if\_t<>, which allows you to skip typename and ::type (see Section 2.8 for details). Thus, since C++14 you can write

\begin{lstlisting}[style=styleCXX]
template<typename T>
std::enable_if_t<(sizeof(T) > 4)>
foo() {
}
\end{lstlisting}

If a second argument is passed to enable\_if<> or enable\_if\_t<>:

\begin{lstlisting}[style=styleCXX]
template<typename T>
std::enable_if_t<(sizeof(T) > 4), T>
foo() {
	return T();
}
\end{lstlisting}

the enable\_if construct expands to this second argument if the expression yields true. So, if MyType is the concrete type passed or deduced as T, whose size is larger than 4, the effect is

\begin{lstlisting}[style=styleCXX]
MyType foo();
\end{lstlisting}

Note that having the enable\_if expression in the middle of a declaration is pretty clumsy. For this reason, the common way to use std::enable\_if<> is to use an additional function template argument with a default value:

\begin{lstlisting}[style=styleCXX]
template<typename T,
		typename = std::enable_if_t<(sizeof(T) > 4)>>
void foo() {
}
\end{lstlisting}

which expands to

\begin{lstlisting}[style=styleCXX]
template<typename T,
		typename = void>
void foo() {
}
\end{lstlisting}

if sizeof(T) > 4.

If that is still too clumsy, and you want to make the requirement/constraint more explicit, you can define your own name for it using an alias template:

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm}Thanks to Stephen C. Dewhurst for pointing that out.
\end{tcolorbox}

\begin{lstlisting}[style=styleCXX]
template<typename T>
using EnableIfSizeGreater4 = std::enable_if_t<(sizeof(T) > 4)>;

template<typename T,
	typename = EnableIfSizeGreater4<T>>
void foo() {
}
\end{lstlisting}

See Section 20.3 for a discussion of how std::enable\_if is implemented










