

介绍C++模板的一些基础概念和语言特性，通过函数模板和类模板的例子来讨论模板的目的和概念。再介绍一些其他的模板特性，比如非类型模板参数，可变参模板，typename关键字和成员模板。并且，讨论如何处理移动语义，如何声明模板参数，以及如何使用泛型进行编译时编程。作为应用程序程序员和通用库的作者，本节最后会针对一些术语和模板在实际中的应用，给应用开发工程师和泛型库的开发者们提供一些建议。

\begin{flushleft}
\zihao{3} 为何需要模板？
\end{flushleft}

C++要求我们使用特定类型声明变量、函数和大多数其他类型的实体。但是，对于不同的类型，很多代码看起来是相同的。例如，算法快速排序的实现对于不同的数据结构(比如int型array或string型vector)在结构上看起来是相同的，只要所包含的类型可以相互比较。

如果使用的编程语言不支持这种泛型特性，只剩下了糟糕的替代方案:

\begin{enumerate}
\item 
对不同的类型一遍遍的实现相同的算法。

\item 
在一个公共基类(比如\texttt{Object}和\texttt{void*})里面实现通用的算法代码。

\item 
使用特殊的预处理方法。
\end{enumerate}

若是从其它语言转投C++的，可能已经使用过以上的方法了。然而他们都各有各的缺点：

\begin{enumerate}
\item 
一遍遍地实现相同算法，就是在重复地造轮子！并且会犯相同的错误。为了避免犯更多的错误，也不会倾向于使用复杂但高效的算法。

\item 
公共基类里实现统一的代码，就等于放弃了类型检查。而且，有时候某些类必须要从某些特殊的基类派生出来，这会增加代码维护的成本。

\item 
采用预处理的方式，就需要实现一些“愚蠢的文本替换”，这很难兼顾作用域和类型检查，因此也就更容易引发奇怪的错误。
\end{enumerate}

而模板就不会有这些问题，它就是为了一种或者多种未明确定义的类型而定义的函数或者类。使用模板时，需要显式地或者隐式地指定模板参数。由于模板是C++的语言特性，肯定会检查类型和作用域。

目前模板使用的很广，比如在C++标准库中，几乎所有的代码都用到了模板。标准库提供了一些排序算法来排序某种特定类型的值或者对象，也提供类一些数据结构(也叫\textit{容器})来维护某种特定类型的元素，对于字符串而言，这一“特定类型”指的就是“字符”。当然，这只是最基础的功能。模板还允许参数化函数或类的行为，优化代码以及参数化其他信息。这些高级特性会在后面介绍，接下来从简单的模板开始。










