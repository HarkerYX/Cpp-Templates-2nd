对于具有依赖于模板参数的基类类模板，使用名称x本身并不总是等同于\texttt{this->x}，即使成员x被继承。例如:

\begin{lstlisting}[style=styleCXX]
template<typename T>
class Base {
public:
	void bar();
};

template<typename T>
class Derived : Base<T> {
public:
	void foo() {
		bar(); // calls external bar() or error
	}
};
\end{lstlisting}

本例中，解析\texttt{foo()}内部的符号\texttt{bar}，不会考虑\texttt{Base}中定义的\texttt{bar()}。因此，要么出现错误，要么调用另一个\texttt{bar()}实现(例如全局\texttt{bar()})。

我们将在第13.4.2节详细讨论这个问题。目前，根据经验，建议始终对基类中声明的符号进行限定，这些符号在某种程度上依赖于模板参数\texttt{this->}或\texttt{Base<T>::}。














































