In C++, structs, classes, and unions are collectively called class types. Without additional qualification, the word “class” in plain text type is meant to include class types introduced with either the keyword class or the keyword struct.

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm}In C++, the only difference between class and struct is that the default access for class is private, whereas the default access for struct is public. However, we prefer to use class for types that use new C++ features, and we use struct for ordinary C data structure that can be used as “plain old data” (POD).
\end{tcolorbox}

Note specifically that “class type” includes unions, but “class” does not.

There is some confusion about how a class that is a template is called:

\begin{itemize}
\item 
The term class template states that the class is a template. That is, it is a parameterized description of a family of classes.

\item 
The term template class, on the other hand, has been used
\begin{itemize}
\item[-]
as a synonym for class template.

\item[-]
to refer to classes generated from templates.

\item[-]
to refer to classes with a name that is a template-id (the combination of a template name followed by the template arguments specified between < and >).
\end{itemize}

The difference between the second and third meanings is somewhat subtle and unimportant for the remainder of the text.
\end{itemize}

Because of this imprecision, we avoid the term template class in this book.

Similarly, we use function template, member template, member function template, and variable template but avoid template function, template member, template member function, and template variable.

\begin{lstlisting}[style=styleCXX]
template<typename T1, typename T2> // primary class template
class MyClass {
	...
};

template<> // explicit specialization
class MyClass<std::string,float> {
	...
};
\end{lstlisting}

Strictly speaking, this is called an explicit specialization (as opposed to an instantiated or generated specialization).

As described in Section 2.6 on page 33, specializations that still have template parameters are called partial specializations:

\begin{lstlisting}[style=styleCXX]
template<typename T> // partial specialization
class MyClass<T,T> {
	...
};

template<typename T> // partial specialization
class MyClass<bool,T> {
	...
};
\end{lstlisting}

When talking about (explicit or partial) specializations, the general template is also called the primary template.















