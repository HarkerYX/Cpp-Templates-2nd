There are several situations in which the pair (A, P) used for deduction is not obtained from the arguments to a function call and the parameters of a function template. The first situation occurs when the address of a function template is taken. In this case, P is the parameterized type of the function template declaration, and A is the function type underlying the pointer that is initialized or assigned to. For example:

\begin{lstlisting}[style=styleCXX]
template<typename T>
void f(T, T);

void (*pf)(char, char) = &f;
\end{lstlisting}

In this example, P is void(T, T) and A is void(char, char). Deduction succeeds with T substituted with char, and pf is initialized to the address of the specialization f<char>.

Similarly, function types are used for P and A for a few other special situations:

\begin{itemize}
\item 
Determining a partial ordering between overloaded function templates

\item 
 Matching an explicit specialization to a function template

\item 
Matching an explicit instantiation to a template

\item 
Matching a friend function template specialization to a template

\item 
Matching a placement operator delete or operator delete[] to a corresponding placement operator new or operator new[] template
\end{itemize}

Some of these topics, along with the use of template argument deduction for class template partial specializations, are further developed in Chapter 16.

Another special situation occurs with conversion function templates. For example:

\begin{lstlisting}[style=styleCXX]
class S {
	public:
	template<typename T> operator T&();
};
\end{lstlisting}

In this case, the pair (P, A) is obtained as if it involved an argument of the type to which we are attempting to convert and a parameter type that is the return type of the conversion function. The following code illustrates one variation:

\begin{lstlisting}[style=styleCXX]
void f(int (&)[20]);

void g(S s)
{
	f(s);
}
\end{lstlisting}

Here we are attempting to convert S to int (\&)[20]. Type A is therefore int[20] and type P is T. The deduction succeeds with T substituted with int[20].

Finally, some special treatment is also needed for the deduction of the auto placeholder type. That is discussed in Section 15.10.4 on page 303.


































