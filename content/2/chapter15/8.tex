

Template argument deduction is a powerful feature, eliminating the need to explicitly specify template arguments in most calls to function templates and enabling both function template overloading (see Section 1.5 on page 15) and partial class template specialization (see Section 16.4 on page 347).

However, there are a few limitations that programmers may encounter when using templates and those limitations are discussed in this section.

\subsubsubsection{15.8.1\hspace{0.2cm}Allowable Argument Conversions}

Normally, template deduction attempts to find a substitution of the function template parameters that make the parameterized type P identical to type A. However, when this is not possible, the following differences are tolerable when P contains a template parameter in a deduced context:

\begin{itemize}
\item 
If the original parameter was declared with a reference declarator, the substituted P type may be more const/volatile-qualified than the A type.

\item 
If the A type is a pointer or pointer-to-member type, it may be convertible to the substituted P type by a qualification conversion (in other words, a conversion that adds const and/or volatile qualifiers).

\item 
Unless deduction occurs for a conversion operator template, the substituted P type may be a base class type of the A type or a pointer to a base class type of the class type for which A is a pointer type. For example:

\begin{lstlisting}[style=styleCXX]
template<typename T>
class B {
};

template<typename T>
class D : public B<T> {
};

template<typename T> void f(B<T>*);
void g(D<long> dl)
{
	f(&dl); // deduction succeeds with T substituted with long
}
\end{lstlisting}
\end{itemize}

If P does not contain a template parameter in a deduced context, then all implicit conversion are permissible. For example:

\begin{lstlisting}[style=styleCXX]
template<typename T> int f(T, typename T::X);
struct V {
	V();
	struct X {
		X(double);
	};
} v;
int r = f(v, 7.0); // OK: T is deduced to int through the first parameter,
					// which causes the second parameter to have type V::X
					// which can be constructed from a double value
\end{lstlisting}

The relaxed matching requirements are considered only if an exact match was not possible. Even so, deduction succeeds only if exactly one substitution was found to fit the A type to the substituted P type with these added conversions.

Note that these rules are very narrow in scope, ignoring (for example) various conversions that could be applied to the function arguments to make a call succeed. For example, consider the following call to the max() function template shown in Section 15.1 on page 269:

\begin{lstlisting}[style=styleCXX]
std::string maxWithHello(std::string s)
{
	return ::max(s, "hello");
}
\end{lstlisting}

Here, template argument deduction from the first argument deduces T to std::string, while deduction from the second argument deduces T to char[6], so template argument deduction fails, because both parameters use the same template parameter. This failure may come as a surprise, because the string literal "hello" is implicitly convertible to std::string, and the call

\begin{lstlisting}[style=styleCXX]
::max<std::string>(s, "hello")
\end{lstlisting}

would have succeeded.

Perhaps even more surprising is that when the two arguments have different class types derived from a common base class, deduction does not consider that common base class as a candidate for the deduced type. See Section 1.2 on page 7 for a discussion of this issue and possible solutions.

\subsubsubsection{15.8.2\hspace{0.2cm}Class Template Arguments}

Prior to C++17, template argument deduction applied exclusively to function and member function templates. In particular, the arguments for a class template were not deduced from the arguments to a call of one of its constructors. For example:

\begin{lstlisting}[style=styleCXX]
template<typename T>
class S {
	public:
	S(T b) : a(b) {
	}
	private:
	T a;
};

S x(12); // ERROR before C++17: the class template parameter T was not deduced from
// the constructor call argument 12
\end{lstlisting}

This limitation is lifted in C++17—see Section 15.12 on page 313.




\subsubsubsection{15.8.3\hspace{0.2cm}Default Call Arguments}

Default function call arguments can be specified in function templates just as they are in ordinary functions:

\begin{lstlisting}[style=styleCXX]
template<typename T>
void init (T* loc, T const& val = T())
{
	*loc = val;
}
\end{lstlisting}

In fact, as this example shows, the default function call argument can depend on a template parameter. Such a dependent default argument is instantiated only if no explicit argument is provided—a principle that makes the following example valid:

\begin{lstlisting}[style=styleCXX]
class S {
	public:
	S(int, int);
};

S s(0, 0);

int main()

{
	init(&s, S(7, 42)); // T() is invalid for T = S, but the default
	// call argument T() needs no instantiation
	// because an explicit argument is given
}
\end{lstlisting}

Even when a default call argument is not dependent, it cannot be used to deduce template arguments. This means that the following is invalid C++:

\begin{lstlisting}[style=styleCXX]
template<typename T>
void f (T x = 42)
{ }

int main()
{
	f<int>(); // OK: T = int
	f(); // ERROR: cannot deduce T from default call argument
}
\end{lstlisting}

\subsubsubsection{15.8.4\hspace{0.2cm}Exception Specifications}

Like default call arguments, exception specifications are only instantiated when they are needed. This means that they do not participate in template argument deduction. For example:

\begin{lstlisting}[style=styleCXX]
template<typename T>
void f(T, int) noexcept(nonexistent(T())); // #1

template<typename T>
void f(T, ...); // #2 (C-style vararg function)
void test(int i)
{
	f(i, i); // ERROR: chooses #1 , but the expression nonexistent(T()) is ill-formed
}
\end{lstlisting}

The noexcept specification in the function marked \#1 tries to call a nonexistent function. Normally, such an error directly within the declaration of the function template would trigger a template argument deduction failure (SFINAE), allowing the call f(i, i) to succeed by selecting the function marked \#2 that is an otherwise lesser match (matching with an ellipsis parameter is the worst kind of match from the point of overload resolution; see Appendix C). However, because exception specifications do not participate in template argument deduction, overload resolution selects \#1 and the program becomes ill-formed when the noexcept specification is later instantiated.

The same rules apply to exception specifications that list the potential exception types:

\begin{lstlisting}[style=styleCXX]
template<typename T>
void g(T, int) throw(typename T::Nonexistent); // #1

template<typename T>
void g(T, ...); // #2

void test(int i)
{
	g(i, i); // ERROR: chooses #1 , but the type T::Nonexistent is ill-formed
}
\end{lstlisting}

However, these “dynamic” exception specifications have been deprecated since C++11 and were removed in C++17.


















