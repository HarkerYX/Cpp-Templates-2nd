
C++11 includes the ability to declare a variable whose type is deduced from its initializer. It also provides a mechanism to express the type of a named entity (a variable or function) or of an expression. These facilities turned out to be very convenient, and C++14 and C++17 added additional variations on that theme.

\subsubsubsection{15.10.1\hspace{0.2cm}The autoType Specifier}

The auto type specifier can be used in a number of places (primarily, namespace scopes and local scopes) to deduce the type of a variable from its initializer. In such cases, auto is called a placeholder type (another placeholder type, decltype(auto), will be described a little later in Section 15.10.2 on page 298). For example:

\begin{lstlisting}[style=styleCXX]
template<typename Container>
void useContainer(Container const& container)
{
	auto pos = container.begin();
	while (pos != container.end()) {
		auto& element = *pos++;
		... // operate on the element
	}
}
\end{lstlisting}

The two uses of auto in the example above eliminate the need to write two long and potentially complicated types, the container’s iterator type and the iterator’s value type:

\begin{lstlisting}[style=styleCXX]
typename Container::const_iterator pos = container.begin();
...
typename std::iterator_traits<typename Container::iterator>::reference
	element = *pos++;
\end{lstlisting}

Deduction for auto uses the same mechanism as template argument deduction. The type specifier auto is replaced by an invented template type parameter T, then deduction proceeds as if the variable were a function parameter and its initializer the corresponding function argument. For the first auto example, that corresponds to the following situation:

\begin{lstlisting}[style=styleCXX]
template<typename T> void deducePos(T pos);
deducePos(container.begin());
\end{lstlisting}

where T is the type to be deduced for auto. One of the immediate consequences of this is that a variable of type auto will never be a reference type. The use of auto\& within the second auto example illustrates how one produces a reference to a deduced type. Its deduction is equivalent to the following function template and call:

\begin{lstlisting}[style=styleCXX]
template<typename T> deduceElement(T& element);
deduceElement(*pos++);
\end{lstlisting}

Here, element will always be of reference type, and its initializer cannot produce a temporary.

It is also possible to combine auto with rvalue references, but doing so makes it behave like a forwarding reference, because the deduction model for

\begin{lstlisting}[style=styleCXX]
auto&& fr = ...;
\end{lstlisting}

is based on a function template:

\begin{lstlisting}[style=styleCXX]
template<typename t> void f(T&& fr); // auto replaced by template parameter T
\end{lstlisting}

That explains the following example:

\begin{lstlisting}[style=styleCXX]
int x;
auto&& rr = 42; // OK: rvalue reference binds to an rvalue (auto = int)
auto&& lr = x; // Also OK: auto = int& and reference collapsing makes
// lr an lvalue reference
\end{lstlisting}

This technique is frequently used in generic code to bind the result of a function or operator invocation whose value category (lvalue vs. rvalue) isn’t known, without having to make a copy of that result. For example, it is often the preferred way to declare the iterating value in a range-based for loop:

\begin{lstlisting}[style=styleCXX]
template<typename Container> void g(Container c) {
	for (auto&& x: c) {
		...
	}
}
\end{lstlisting}

Here we do not know the signatures of the container’s iteration interfaces, but by using auto\&\& we can be confident that no additional copies are made of the values we are iterating through. std::forward<T>() can be invoked as usual on the variable as usual, if perfect forwarding of the bound value is desired. That enables a kinds of “delayed” perfect forwarding. See Section 11.3 on page 167 for an example.

In addition to references, one can combine the auto specifier to make a variable const, a pointer, a member pointer, and so on, but auto has to be the “main” type specifier of the declaration. It cannot be nested in a template argument or part of the declarator that follows the type specifier. The following example illustrates various possibilities:

\begin{lstlisting}[style=styleCXX]
template<typename T> struct X { T const m; };
auto const N = 400u; // OK: constant of type unsigned int
auto* gp = (void*)nullptr; // OK: gp has type void*
auto const S::*pm = &X<int>::m; // OK: pm has type int const X<int>::*
X<auto> xa = X<int>(); // ERROR: auto in template argument
int const auto::*pm2 = &X<int>::m; // ERROR: auto is part of the “declarator”
\end{lstlisting}

There are no technical reasons why C++ could not support all the cases in this last example, but the C++ committee felt that the benefits were outweighed by both the additional implementation cost and the potential for abuse.

In order to avoid confusing both programmers and compilers, the old use of auto as a “storage class specifier” is no longer permitted in C++11 (and later standards):

\begin{lstlisting}[style=styleCXX]
int g() {
	auto int r = 24; // valid in C++03 but invalid in C++11
	return r;
}
\end{lstlisting}

This old use of auto (inherited from C) is always redundant. Most compilers can usually disambiguate that use from the new use as a placeholder (even though they don’t have to), offering a transition path from older C++ code to newer C++ code. The old use of auto is very rare in practice, however.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{Deduced Return Types}

C++14 added another situation where a deducible auto placeholder type can appear: function return types. For example:

\begin{lstlisting}[style=styleCXX]
auto f() { return 42; }
\end{lstlisting}

defines a function with return type int (the type of 42). This can be expressed using trailing return type syntax also:

\begin{lstlisting}[style=styleCXX]
auto f() -> auto { return 42; }
\end{lstlisting}

In the latter case, the first auto announces the trailing return type, and the second auto is the placeholder type to deduce. There is little reason to favor that more verbose syntax, however.

The same mechanism exists for lambdas by default: If no return type is specified explicitly, the lambda’s return type is deduced as if it were auto:

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm}Although C++14 introduced deduced return types in general, they were already available to C++11 lambdas using a specification that was not worded in terms of deduction. In C++14, that specification was updated to use the general auto deduction mechanism (from a programmer’s point of view, there is no difference).
\end{tcolorbox}

\begin{lstlisting}[style=styleCXX]
auto lm = [] (int x) { return f(x); };
// same as: [] (int x) -> auto f return f(x); g
\end{lstlisting}

Functions can be declared separately from their definition. That is true with functions whose return type is deduced also:

\begin{lstlisting}[style=styleCXX]
auto f(); // forward declaration
auto f() { return 42; }
\end{lstlisting}

However, the forward declaration is of very limited use in a case like this, since the definition must be visible at any point where the function is used. Perhaps surprisingly, it is not valid to provide a forward declaration with a “resolved” return type. For example:

\begin{lstlisting}[style=styleCXX]
int known();
auto known() { return 42; } // ERROR: incompatible return type
\end{lstlisting}

Mostly, the ability to forward declare a function with a deduced return type is only useful to be able to move a member function definition outside the class definition because of stylistic preferences:

\begin{lstlisting}[style=styleCXX]
struct S {
	auto f(); // the definition will follow the class definition
};
auto S::f() { return 42; }
\end{lstlisting}

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{Deducible Nontype Parameters}

Prior to C++17, nontype template arguments had to be declared with a specific type. However, that type could be a template parameter type. For example:

\begin{lstlisting}[style=styleCXX]
template<typename T, T V> struct S;
S<int, 42>* ps;
\end{lstlisting}

n this example, having to specify the type of the nontype template argument—that is, specifying int in addition to 42—can be tedious. C++17 therefore added the ability to declare nontype template parameters whose actual types are deduced from the corresponding template argument. They are declared as follows:

\begin{lstlisting}[style=styleCXX]
template<auto V> struct S;
\end{lstlisting}

which enables

\begin{lstlisting}[style=styleCXX]
S<42>* ps;
\end{lstlisting}

Here the type of V for S<42> is deduced to be int because 42 has type int. Had we written S<42u> instead, the type of V would have been deduced to be unsigned int (see Section 15.10.1 on page 294 for the details of deducing auto type specifiers).

Note that the general constraints on the type of nontype template parameters remain in effect. For example:

\begin{lstlisting}[style=styleCXX]
S<3.14>* pd; // ERROR: floating-point nontype argument
\end{lstlisting}

A template definition with that kind of deducible nontype parameter often also needs to express the actual type of the corresponding argument. That is easily done using the decltype construct (see Section 15.10.2 on page 298). For example:

\begin{lstlisting}[style=styleCXX]
template<auto V> struct Value {
	using ArgType = decltype(V);
};
\end{lstlisting}

auto nontype template parameters are also useful to parameterize templates on members of classes. For example:

\begin{lstlisting}[style=styleCXX]
template<typename> struct PMClassT;
template<typename C, typename M> struct PMClassT<M C::*> {
	using Type = C;
};

template<typename PM> using PMClass = typename PMClassT<PM>::Type;
template<auto PMD> struct CounterHandle {
	PMClass<decltype(PMD)>& c;
	CounterHandle(PMClass<decltype(PMD)>& c): c(c) {
	}
	void incr() {
		++(c.*PMD);
	}
};

struct S {
	int i;
};

int main() {
	S s{41};
	CounterHandle<&S::i> h(s);
	h.incr(); // increases s.i
}
\end{lstlisting}

Here we used a helper class template PMClassT to retrieve from a pointer-to-member type its “parent” class type, using class template partial specialization (described in Section 16.4 on page 347).

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm}The same technique can be used to extract the associated member type: Instead of using Type = C; use using Type = M;.
\end{tcolorbox}

With an auto template parameter, we only have to specify the pointer-to-member constant \&S::i as a template argument. Prior to C++17, we’d also have to specify a pointer-member-type; that is, something like

\begin{lstlisting}[style=styleCXX]
OldCounterHandle<int S::*, &S::i>
\end{lstlisting}

which is unwieldy and feels redundant.

\begin{lstlisting}[style=styleCXX]
As you’d expect, that feature can also be used for nontype parameter packs:
template<auto... VS> struct Values {
};
Values<1, 2, 3> beginning;
Values<1, ’x’, nullptr> triplet;
\end{lstlisting}

The triplet example shows that each nontype parameter element of the pack can be deduced to a distinct type. Unlike the case of multiple variable declarators (see Section 15.10.4 on page 303), there is no requirement that all the deductions be equivalent.

If we want to force a homogeneous pack of nontype template parameters, that is possible too:

\begin{lstlisting}[style=styleCXX]
template<auto V1, decltype(V1)... VRest> struct HomogeneousValues {
};
\end{lstlisting}

However, the template argument list cannot be empty in that particular case.

See Section 3.4 on page 50 for a complete example using auto as template parameter type.

\subsubsubsection{15.10.2\hspace{0.2cm}Expressing the Type of an Expression with decltype}

While auto avoids the need to write out the type of the variable, it doesn’t easily allow one to use the type of that variable. The decltype keyword resolves that issue: It allows a programmer to express the precise type of an expression or declaration. However, programmers should be careful about a subtle difference in what decltype produces, depending on whether the passed argument is a declared entity or an expression:

\begin{itemize}
\item 
If e is the name of an entity (such as a variable, function, enumerator, or data member) or a class member access, decltype(e) yields the declared type of that entity or the denoted class member. Thus, decltype can be used to inspect the type of a variable.

This is useful when one wants to exactly match the type of an existing declaration. For example, consider the following variables y1 and y2:

\begin{lstlisting}[style=styleCXX]
auto x = ...;
auto y1 = x + 1;
decltype(x) y2 = x + 1;
\end{lstlisting}

Depending on the initializer for x, y1 may or may not have the same type as x: It depends on behavior of +. If x were deduced to an int, y1 would also be an int. If x were deduced to a char, y1 would be an int, because the sum of a char with 1 (which by definition is an int) is an int. The use of decltype(x) in the type of y2 ensures that it always has the same type as x.

\item 
Otherwise, if e is any other expression, decltype(e) produces a type that reflects the type and value category of that expression as follows:

\begin{itemize}
\item[-]
If e is an lvalue of type T, decltype(e) produces T\&

\item[-]
If e is an xvalue of type T, decltype(e) produces T\&\&.

\item[-]
If e is a prvalue of type T, decltype(e) produces T.
\end{itemize}

See Appendix B for a detailed discussion about value categories. 

\end{itemize}

The difference can be demonstrated by the following example:

\begin{lstlisting}[style=styleCXX]
e difference can be demonstrated by the following example:
void g (std::string&& s)
{
	// check the type of s:
	std::is_lvalue_reference<decltype(s)>::value; // false
	std::is_rvalue_reference<decltype(s)>::value; // true (s as declared)
	std::is_same<decltype(s),std::string&>::value; // false
	std::is_same<decltype(s),std::string&&>::value; // true
	
	// check the value category of s used as expression:
	std::is_lvalue_reference<decltype((s))>::value; // true (s is an lvalue)
	std::is_rvalue_reference<decltype((s))>::value; // false
	std::is_same<decltype((s)),std::string&>::value; // true (T& signals an lvalue)
	std::is_same<decltype((s)),std::string&&>::value; // false
}
\end{lstlisting}

In the first four expressions, decltype is invoked for the variable s:

\begin{lstlisting}[style=styleCXX]
decltype(s) // declared type of entity e designated by s
\end{lstlisting}

which means that decltype produces the declared type of s, std::string\&\&. In the last four expressions, the operand of the decltype construct is not just a name because in every case the expression is (s), which is a parenthesized name. In that case, the type will reflect the value category of (s):

\begin{lstlisting}[style=styleCXX]
decltype((s)) // check the value category of (s)
\end{lstlisting}

Our expression refers to a variable by name and is thus an lvalue:

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm}As mentioned elsewhere, treating a parameter of rvalue reference type as an lvalue rather than an xvalue is intended as a safety feature, because anything with a name (like a parameter) can easily be referenced multiple times in a function. If it were an xvalue, its first use might cause its value to be “moved away,” causing surprising behavior for every subsequent use. See Section 6.1 on page 91 and Section 15.6.3 on page 280.
\end{tcolorbox}

By the rules above, this means that decltype(s) is an ordinary (i.e., lvalue) reference to std::string (since the type of (s) is std::string). This is one of the few places in C++ where parenthesizing an expression changes the meaning of the program other than affecting the associativity of operators.

The fact that decltype computes the type of an arbitrary expression e can be helpful in various places. Specifically, decltype(e) preserves enough information about an expression to make it possible to describe the return type of a function that returns the expression e itself “perfectly”: decltype computes the type of that expression, but it also propagates the value category of the expression to the caller of the function. For example, consider a simple forwarding function g() that returns the results of calling f():

\begin{lstlisting}[style=styleCXX]
??? f();

decltype(f()) g()
{
	return f();
}
\end{lstlisting}

The return type of g() depends on the return type of f(). If f() were to return int\&, the computation of g()’s return type would first determine that the expression f() has type int. This expression is an lvalue, because f() returns an lvalue reference, so the declared return type of g() becomes int\&. Similarly, if the return type of f() were an rvalue reference type, the call f() would be an xvalue, and decltype would produce an rvalue reference type that exactly matches the type returned by f(). Essentially, this form of decltype takes the primary characteristics of an arbitrary expression—its type and value category—and encodes them in the type system in a manner that enables perfect forwarding of return values.

decltype can also be useful when the value-producing auto deduction is not sufficient. For example, assume we have a variable pos of some unknown iterator type, and we want to create a variable element that refers to the element stored by pos. We could use

\begin{lstlisting}[style=styleCXX]
auto element = *pos;
\end{lstlisting}

However, this will always make a copy of the element. If we instead try

\begin{lstlisting}[style=styleCXX]
auto& element = *pos;
\end{lstlisting}

then we will always receive a reference to the element, but the program will fail if the iterator’s operator* returns a value.

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm}When we used the latter formulation in our introductory example of auto, we implicitly assumed that the iterators produced references to some underlying storage. While this is generally true for container iterator (and required by the standard containers other than vector<bool>), it is not the case for all iterators.
\end{tcolorbox}

To address this problem, we can use decltype so that the value- or reference-ness of the iterator’s operator* is preserved:

\begin{lstlisting}[style=styleCXX]
decltype(*pos) element = *pos;
\end{lstlisting}

This will use a reference when the iterator supports it and copy the value when the iterator does not. Its primary deficiency is that it requires the initializer expression to be written twice: once in the decltype (where it is not evaluated) and once as the actual initializer. C++14 introduces the decltype(auto) construct to address that issue, which we will discuss next.

\subsubsubsection{15.10.3\hspace{0.2cm}decltype(auto)}

C++14 adds a feature that is a combination of auto and decltype: decltype(auto). Like the auto type specifier, it is a placeholder type, and the type of a variable, return type, or template argument is determined from the type of the associated expression (initializer, return value, or template argument). However, unlike just auto, which uses the rules for template argument deduction to determine the type of interest, the actual type is determined by applying the decltype construct directly to the expression. An example illustrates this:

\begin{lstlisting}[style=styleCXX]
int i = 42; // i has type int
int const& ref = i; // ref has type int const& and refers to i

auto x = ref; // x1 has type int and is a new independent object

decltype(auto) y = ref; // y has type int const& and also refers to i
\end{lstlisting}

The type of y is obtained by applying decltype to the initializer expression, here ref, which is int const\&. In contrast, the rules for auto type deduction produce type int.

Another example shows the difference when indexing a std::vector (which produces an lvalue):

\begin{lstlisting}[style=styleCXX]
std::vector<int> v = { 42 };
auto x = v[0]; // x denotes a new object of type int
decltype(auto) y = v[0]; // y is a reference (type int&)
\end{lstlisting}

This neatly addresses the redundancy in our previous example:

\begin{lstlisting}[style=styleCXX]
decltype(*pos) element = *pos;
\end{lstlisting}

which can now be rewritten as

\begin{lstlisting}[style=styleCXX]
decltype(auto) element = *pos;
\end{lstlisting}

It is frequently convenient for return types too. Consider the following example:

\begin{lstlisting}[style=styleCXX]
template<typename C> class Adapt
{
	C container;
	...
	decltype(auto) operator[] (std::size_t idx) {
		return container[idx];
	}
};
\end{lstlisting}

If container[idx] produces an lvalue, we want to pass that lvalue to the caller (who might wish to takes its address or modify it): That requires an lvalue reference type, which is exactly what decltype(auto) resolves to. If instead a prvalue is produced, a reference type would result in dangling references, but, fortunately, decltype(auto) will produce an object type (not a reference type) for that case.

Unlike auto, decltype(auto) does not allow specifiers or declarator operators that modify its type. For example:

\begin{lstlisting}[style=styleCXX]
decltype(auto)* p = (void*)nullptr; // invalid
int const N = 100;
decltype(auto) const NN = N*N; // invalid
\end{lstlisting}

Note also that parentheses in the initializer may be significant (since they are significant for the decltype construct as discussed in Section 6.1 on page 91):

\begin{lstlisting}[style=styleCXX]
int x;
decltype(auto) z = x; // object of type int
decltype(auto) r = (x); // reference of type int&
\end{lstlisting}

This especially means that parentheses can have a severe impact on the validity of return statements:

\begin{lstlisting}[style=styleCXX]
int g();
...
decltype(auto) f() {
	int r = g();
	return (r); // run-time ERROR: returns reference to temporary
}
\end{lstlisting}

Since C++17, decltype(auto) can also be used for deducible nontype parameters (see Section 15.10.1 on page 296). The following example illustrates this:

\begin{lstlisting}[style=styleCXX]
template<decltype(auto) Val> class S
{
	...
};
constexpr int c = 42;
extern int v = 42;
S<c> sc; // #1 produces S<42>
S<(v)> sv; // #2 produces S<(int&)v>
\end{lstlisting}

In line \#1 , the lack of parentheses around c causes the deducible parameter to be of the type of c itself (i.e., int). Because c is a constant-expression of value 42, this is equivalent to S<42>. In line \#2 , the parentheses cause decltype(auto) to become a reference type int\&, which can bind to the global variable v of type int. Thus, with this declaration the class template depends on a reference to v, and any change of the value of v might impact the behavior of class S (see Section 11.4 on page 167 for details). (S<v> without parentheses, on the other hand, would be an error, because decltype(v) is int, and therefore a constant argument of type int would be expected. However, v doesn’t designate a constant int value.)

Note that the nature of the two cases is somewhat different; we therefore think that such nontype template parameters are likely to cause surprise and do not anticipate that they will be widely used.

Finally, a comment about using deduced nontype parameters in function templates:

\begin{lstlisting}[style=styleCXX]
template<auto N> struct S {};
template<auto N> int f(S<N> p);
S<42> x;
int r = f(x);
\end{lstlisting}

In this example, the type of the parameter N of function template f<>() is deduced from the type of the nontype parameter of S. That’s possible because a name of the form X<...> where X is a class template is a deduced context. However, there are also many patterns that cannot be deduced that way:

\begin{lstlisting}[style=styleCXX]
template<auto V> int f(decltype(V) p);
int r1 = deduce<42>(42); // OK
int r2 = deduce(42); // ERROR: decltype(V) is a nondeduced context
\end{lstlisting}

In this case, decltype(V) is a nondeduced context: There is no unique value of V that matches the argument 42 (e.g., decltype(7) produces the same type as decltype(42)). Therefore, the nontype template parameter must be specified explicitly to be able to call this function.


\subsubsubsection{15.10.4\hspace{0.2cm}Special Situations for autoDeduction}

There are a few special situations for the otherwise simple deduction rules of auto. The first is when the initializer for a variable is an initializer list. The corresponding deduction for a function call would fail, because we cannot deduce a template type parameter from an initializer list argument:

\begin{lstlisting}[style=styleCXX]
template<typename T>
void deduceT (T);
...
deduceT({ 2, 3, 4}); // ERROR
deduceT({ 1 }); // ERROR
\end{lstlisting}

However, if our function has a more specific parameter as follows

\begin{lstlisting}[style=styleCXX]
template<typename T>
void deduceInitList(std::initializer_list<T>);
...
deduceInitList({ 2, 3, 5, 7 }); // OK: T deduced as int
\end{lstlisting}

then deduction succeeds. Copy-initializing (i.e., initialization with the = token) an auto variable with an initializer list is therefore defined in terms of that more specific parameter:

\begin{lstlisting}[style=styleCXX]
auto primes = { 2, 3, 5, 7 }; // primes is std::initializer_list<int>
deduceT(primes); // T deduced as std::initializer_list<int>
\end{lstlisting}

Before C++17, the corresponding direct-initialization of auto variables (i.e., without the = token) was also handled that way, but this was changed in C++17 to better match the behavior expected by most programmers:

\begin{lstlisting}[style=styleCXX]
auto oops { 0, 8, 15 }; // ERROR in C++17
auto val { 2 }; // OK: val has type int in C++17
\end{lstlisting}

Prior to C++17, both initializations were valid, initializing both both oops and val of type initializer\_list<int>.

Interestingly, returning a braced initializer list for a function with a deducible placeholder type is invalid:

\begin{lstlisting}[style=styleCXX]
auto subtleError() {
	return { 1, 2, 3 }; // ERROR
}
\end{lstlisting}

That is because an initializer list in function scope is an object that points into an underlying array object (with the element values specified in the list) that expires when the function returns. Allowing the construct would thus encourage what is in effect a dangling reference.

Another special situation occurs when multiple variable declarations share the same auto, as in the following:

\begin{lstlisting}[style=styleCXX]
auto first = container.begin(), last = container.end();
\end{lstlisting}

In such cases, deduction is performed independently for each declaration. In other words, there is an invented template type parameter T1 for first and another invented template type parameter T2 for last. Only if both deductions succeed, and the deductions for T1 and T2 are the same type, are the declarations well-formed. This can produce some interesting cases:

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm}This example does not use our usual style for placing the * immediately adjacent to the auto, because it could mislead the reader into thinking we are declaring two pointers. On the other hand, the opacity of these declarations is a good argument for being conservative when declaring multiple entities in a single declaration
\end{tcolorbox}

\begin{lstlisting}[style=styleCXX]
char c;
auto *cp = &c, d = c; // OK
auto e = c, f = c+1; // ERROR: deduction mismatch char vs. int
\end{lstlisting}

Here, two pairs of variables are declared with a shared auto specifier. The declarations of cp and d deduce the same type char for auto, so this is valid code. The declarations of e and f, however, deduce char and int due to the promotion to int when computing c+1, and that inconsistency results in an error.

A somewhat parallel special situation can also occur with placeholders for deduced return types. Consider the following example:

\begin{lstlisting}[style=styleCXX]
auto f(bool b) {
	if (b) {
		return 42.0; // deduces return type double
	} else {
		return 0; // ERROR: deduction conflict
	}
}
\end{lstlisting}

In this case, each return statement is deduced independently, but if different types are deduced, the program is invalid. If the returned expression calls the function recursively, deduction cannot occur and the program is invalid unless a prior deduction already determined the return type. That means that the following code is invalid:

\begin{lstlisting}[style=styleCXX]
auto f(int n)
{
	if (n > 1) {
		return n*f(n-1); // ERROR: type of f(n-1) unknown
	} else {
		return 1;
	}
}
\end{lstlisting}

but the following otherwise equivalent code is fine:

\begin{lstlisting}[style=styleCXX]
auto f(int n)
{
	if (n <= 1) {
		return 1; // return type is deduced to be int
	} else {
		return n*f(n-1); // OK: type of f(n-1) is int and so is type of n*f(n-1)
	}
}
\end{lstlisting}

Deduced return types have another special case with no counterpart in deduced variable types or deduced nontype parameter types:

\begin{lstlisting}[style=styleCXX]
auto f1() { } // OK: return type is void
auto f2() { return; } // OK: return type is void
\end{lstlisting}

Both f1() and f2() are valid and have a void return type. However, if the return type pattern cannot match void, such cases are invalid:

\begin{lstlisting}[style=styleCXX]
auto* f3() {} // ERROR: auto* cannot deduce as void
\end{lstlisting}

As you’d expect, any use of a function template with a deduced return type requires the immediate instantiation of that template to determine the return type with certainty. That, however, has a surprising consequence when it comes to SFINAE (described in Section 8.4 on page 129 and Section 15.7 on page 284). Consider the following example:

\hspace*{\fill} \\ %插入空行
\noindent
\textit{deduce/resulttypetmpl.cpp}
\begin{lstlisting}[style=styleCXX]
template<typename T, typename U>
auto addA(T t, U u) -> decltype(t+u)
{
	return t + u;
}

void addA(...);

template<typename T, typename U>
auto addB(T t, U u) -> decltype(auto)
{
	return t + u;
}
void addB(...);
struct X {
};

using AddResultA = decltype(addA(X(), X())); // OK: AddResultA is void

using AddResultB = decltype(addB(X(), X())); // ERROR: instantiation of addB<X>
// is ill-formed
\end{lstlisting}

Here, the use of decltype(auto) rather than decltype(t+u) for addB() causes an error during overload resolution: The function body of the addB() template must be fully instantiated to determine its return type. That instantiation isn’t in the immediate context (see Section 15.7.1 on page 285) of the call to addB() and therefore doesn’t fall under the SFINAE filter but results in an outright error. It is therefore important to remember that deduced return types are not merely a shorthand for a complex explicit return type and they should be used with care (i.e., with the understanding that they shouldn’t be called in the signatures of other function templates that would count on SFINAE properties).

\subsubsubsection{15.10.5\hspace{0.2cm}Structured Bindings}

C++17 added a new feature known as structured bindings.

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm} The term structured bindings was used in the original proposal for the feature and was also eventually used for the formal specification in the language. Briefly, however, that specification used the term decomposition declarations instead.
\end{tcolorbox}

It is most easily introduced with a small example:

\begin{lstlisting}[style=styleCXX]
struct MaybeInt { bool valid; int value; };
MaybeInt g();
auto const&& [b, N] = g(); // binds b and N to the members of the result of g()
\end{lstlisting}

The call to g() produces a value (in this case a simple class aggregate of type MaybeInt) that can be decomposed into “elements” (in this case, the data members of MaybeInt). The value of that call is produced as if the bracketed list of identifiers [b, N] were replaced by a distinct variable name. If that name were e, the initialization would be equivalent to:

\begin{lstlisting}[style=styleCXX]
auto const&& e = g();
\end{lstlisting}

The bracketed identifiers are then bound to the elements of e. Thus, you can think of [b, N] as introducing names for the pieces of e (we will discuss some details of that binding below).

Syntactically, a structured binding must always have an auto type optionally extended by const and/or volatile qualifiers and/or \&and/or \&\& declarator operators (but not a * pointer declarator or some other declarator construct). It is followed by a bracketed list containing at least one identifier (reminiscent of the “capture” list of lambdas). That in turn has to be followed by an initializer.

Three different kinds of entities can initialize a structured binding:

\begin{enumerate}
\item
The first case is the simple class type, where all the nonstatic data members are public (as in our example above). For this case to apply, all the nonstatic data members have to be public (either all directly in the class itself or all in the same, unambiguous public base class; no anonymous unions may be involved). In that case, the number of bracketed identifiers must equal the number of members, and using one of these identifiers within the scope of the structured bindings amounts to using the corresponding member of the object denoted by e (with all the associated properties; e.g., if the corresponding member is a bit field, it is not possible to take its address).

\item
The second case corresponds to arrays. Here is an example:

\begin{lstlisting}[style=styleCXX]
int main() {
	double pt[3];
	auto& [x, y, z] = pt;
	x = 3.0; y = 4.0; z = 0.0;
	plot(pt);
}
\end{lstlisting}

Unsurprisingly, the bracketed initializers are just shorthand for the corresponding elements of the unnamed array variable. The number of array elements must equal the number of bracketed initializers.

Here is another example:

\begin{lstlisting}[style=styleCXX]
auto f() -> int(&)[2]; // f() returns reference to int array

auto [ x, y ] = f(); // #1
auto& [ r, s ] = f(); // #2
\end{lstlisting}

Line \#1 is special: Ordinarily, the entity e described earlier would be deduced from the following for this case:

\begin{lstlisting}[style=styleCXX]
auto e = f();
\end{lstlisting}

However, that would deduce the decayed pointer to the array, which is not what happens when performing the structured binding of an array. Instead, e is deduced to be a variable of array type corresponding to the type of the initializer. Then that array is copied from the initializer, element by element: That is a somewhat unusual concept for built-in arrays.

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm}The other two places where built-in arrays are copied are lambda captures and generated copy constructors.
\end{tcolorbox}

Finally, x and y become aliases for the expressions e[0] and e[1], respectively.

Line \#2 , does not involve array copying and follows the usual rules for auto. So the hypothetical e is declared as follows:

\begin{lstlisting}[style=styleCXX]
auto& e = f();
\end{lstlisting}

which yields a reference to an array, and x and y again become aliases for the expressions e[0] and e[1], respectively (which are lvalues referring directly to the elements of the array produced by the call to f()).

\item
Finally, a third option allows std::tuple-like classes to have their elements decomposed through a template-based protocol using get<>(). Let E be the type of the expression (e) with e declared as above. Because E is the type of an expression, it is never a reference type. If the expression std::tuple\_size<E>::value is a valid integral constant expression, it must equal the number of bracketed identifiers (and the protocol kicks in, taking precedence over the first option but not the second option for arrays). Let’s denote the bracketed identifiers by n0, n1, n2, and so forth. If e has any member named get, then the behavior is as if these identifiers are declared as

\begin{lstlisting}[style=styleCXX]
std::tuple_element<i, E>::type& ni = e.get<i>();
\end{lstlisting}

if e was deduced to have a reference type, or

\begin{lstlisting}[style=styleCXX]
std::tuple_element<i, E>::type&& ni = e.get<i>();
\end{lstlisting}

otherwise. If e has no member get, then the corresponding declarations become instead

\begin{lstlisting}[style=styleCXX]
std::tuple_element<i, E>::type& ni = get<i>(e);
\end{lstlisting}

or

\begin{lstlisting}[style=styleCXX]
std::tuple_element<i, E>::type&& ni = get<i>(e);
\end{lstlisting}

where get is only looked up in associated classes and namespaces. (In all cases, get is assumed to be a template and therefore the < follows is an angle bracket.) The std::tuple, std::pair, and std::array templates all implement this protocol, making, for example, the following code valid:

\begin{lstlisting}[style=styleCXX]
#include <tuple>

std::tuple<bool, int> bi{true, 42};
auto [b, i] = bi;
int r = i; // initializes r to 42
\end{lstlisting}

However, it is not difficult to add specializations of std::tuple\_size, std::tuple\_element, and a function template or member function template get<>() that will make this mechanism work for an arbitrary class or enumeration type. For example:

\begin{lstlisting}[style=styleCXX]
#include <utility>

enum M {};

template<> class std::tuple_size<M> {
	public:
	static unsigned const value = 2; // map M to a pair of values
};
template<> class std::tuple_element<0, M> {
	public:
	using type = int; // the first value will have type int
};
template<> class std::tuple_element<1, M> {
	public:
	using type = double; // the second value will have type double
};

template<int> auto get(M);
template<> auto get<0>(M) { return 42; }
template<> auto get<1>(M) { return 7.0; }

auto [i, d] = M(); // as if: int&& i = 42; double&& d = 7.0;
\end{lstlisting}

\end{enumerate}

Note that you only need to include <utility> to use the two tuple-like access helper functions std::tuple\_size<> and std::tuple\_element<>.

In addition, note that the third case above (using the tuple-like protocol) performs an actual initialization of the bracketed initializers and the bindings are actual reference variables; they are not just aliases for another expression (unlike the first two cases using simple class types and arrays). That’s of interest because that reference initialization could go wrong; for example, it might throw  an exception, and that exception is now unavoidable. However, the C++ standardization committee also discussed the possibility of not associating the identifiers with initialized references but instead having each later use of the identifiers evaluate a get<>() expression. That would have allowed structured bindings to be used with types where the “first” value must be tested before accessing the “second” value (e.g., based on std::optional).


\subsubsubsection{15.10.6\hspace{0.2cm}Generic Lambdas}

Lambdas have quickly become one of the most popular C++11 features, in part because they significantly ease the use of the functional constructs in the C++ standard library and in many other modern
C++ libraries, due largely to their concise syntax. However, within templates themselves, lambdas
can become fairly verbose due to the need to spell out the parameter and result types. For example, consider a function template that finds the first negative value from a sequence:

\begin{lstlisting}[style=styleCXX]
template<typename Iter>
Iter findNegative(Iter first, Iter last)
{
	return std::find_if(first, last,
						[] (typename std::iterator_traits<Iter>::value_type
						value) {
							return value < 0;
						});
}
\end{lstlisting}

In this function template, the most complicated part of the lambda (by far) is its parameter type. C++14 introduced the notion of “generic” lambdas, where one or more of the parameter types use auto to deduce the type rather than writing it specifically:

\begin{lstlisting}[style=styleCXX]
template<typename Iter>
Iter findNegative(Iter first, Iter last)
{
	return std::find_if(first, last,
						[] (auto value) {
							return value < 0;
						});
}
\end{lstlisting}

An auto in a parameter of a lambda is handled similarly to an auto in the type of a variable with an initializer: It is replaced by an invented template type parameter T. However, unlike in the variable case, the deduction isn’t performed immediately because the argument isn’t known at the time the lambda is created. Instead, the lambda itself becomes generic (if it wasn’t already), and the invented template type parameter is added to its template parameter list. Thus, the lambda above can be invoked with any argument type, so long as that argument type supports the < 0 operation whose result is convertible to bool. For example, this lambda could be called with either an int or a float value.

To understand what it means for a lambda to be generic, we first consider the implementation model for a nongeneric lambda. Given the lambda

\begin{lstlisting}[style=styleCXX]
[] (int i) {
	return i < 0;
}
\end{lstlisting}

the C++ compiler translates this expression into an instance of a newly invented class specific to this lambda. This instance is called a closure or closure object, and the class is called a closure type. The closure type has a function call operator, and hence the closure is a function object.

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm}This translation model of lambdas is actually used in the specification of the C++ language, making it both a convenient and an accurate description of the semantics. Captured variables become data members, the conversion of a noncapturing lambda to a function pointer is modeled as a conversion function in the class, and so on. And because lambdas are function objects, whenever rules for function objects are defined, they also apply to lambdas.
\end{tcolorbox}

For this lambda, the closure type would look something like the following (we leave out the conversion function to a pointer-to-function value for brevity and simplicity):

\begin{lstlisting}[style=styleCXX]
class SomeCompilerSpecificNameX
{
	public:
	SomeCompilerSpecificNameX(); // only callable by the compiler
	bool operator() (int i) const
	{
		return i < 0;
	}
};
\end{lstlisting}

If you check the type category for a lambda, std::is\_class<> will yield true (see Section D.2.1 on page 705).

A lambda expression thus results in an object of this class (the closure type). For example:

\begin{lstlisting}[style=styleCXX]
foo(...,
	[] (int i) {
		return i < 0;
	});
\end{lstlisting}

creates an object (the closure) of the internal compiler-specific class SomeCompilerSpecificNameX:

\begin{lstlisting}[style=styleCXX]
foo(...,
	SomeCompilerSpecificNameX{}); // pass an object of the closure type
\end{lstlisting}

If the lambda were to capture local variables:

\begin{lstlisting}[style=styleCXX]
int x, y;
...
[x,y](int i) {
	return i > x && i < y;
}
\end{lstlisting}

those captures would be modeled as initializing members of the associated class type:

\begin{lstlisting}[style=styleCXX]
class SomeCompilerSpecificNameY {
private
	int _x, _y;
public:
	SomeCompilerSpecificNameY(int x, int y) // only callable by the compiler
	: _x(x), _y(y) {
	}
	bool operator() (int i) const {
		return i > _x && i < _y;
	}
};
\end{lstlisting}

For a generic lambda, the function call operator becomes a member function template, so our simple generic lambda

\begin{lstlisting}[style=styleCXX]
[] (auto i) {
	return i < 0;
}
\end{lstlisting}

is transformed into the following invented class (again, ignoring the conversion function, which becomes a conversion function template in the generic lambda case):

\begin{lstlisting}[style=styleCXX]
class SomeCompilerSpecificNameZ
{
	public:
	SomeCompilerSpecificNameZ(); // only callable by compiler
	template<typename T>
	auto operator() (T i) const
	{
		return i < 0;
	}
};
\end{lstlisting}

The member function template is instantiated when the closure is invoked, which is usually not at the point where the lambda expression appears. For example:

\begin{lstlisting}[style=styleCXX]
#include <iostream>

template<typename F, typename... Ts> void invoke (F f, Ts... ps)
{
	f(ps...);
}

int main()
{
	invoke([](auto x, auto y) {
		std::cout << x+y << ’\n’
	},
	21, 21);
}
\end{lstlisting}

Here the lambda expression appears in main(), and that’s where an associated closure is created. However, the call operator of the closure isn’t instantiated at that point. Instead, the invoke() function template is instantiated with the closure type as the first parameter type and int (the type of 21) as a second and third parameter type. That instantiation of invoke is called with a copy of the closure (which is still a closure associated with the original lambda), and it instantiates the operator() template of the closure to satisfy the instantiated call f(ps...).












