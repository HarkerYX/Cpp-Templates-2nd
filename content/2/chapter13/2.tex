
在C++中查找名称有许多小技巧，但这里只关注几个主要的。只有在下面两种情景中我们才有必要确认名称查找的细节：(1)按直观处理会犯错的普通例子(2)C++标准给出的错误例子。

限定名在限定构造所隐含的范围内查找。如果该作用域是一个类，那么也可以搜索基类。但是，在查找限定名称时不考虑封闭作用域。基本原则如下:

\begin{lstlisting}[style=styleCXX]
int x;

class B {
	public:
	int i;
};

class D : public B {
};

void f(D* pd)
{
	pd->i = 3; // finds B::i
	D::x = 2; // ERROR: does not find ::x in the enclosing scope
}
\end{lstlisting}

相比之下，不限定名通常会依次在外围作用域中查找(尽管在成员函数定义中，类及其基类的作用域会在其他外围作用域之前搜索)，这称为常规查找。下面是一个基本的例子，展示了常规查找的主要思想:

\begin{lstlisting}[style=styleCXX]
extern int count; // #1

int lookup_example(int count) // #2
{
	if (count < 0) {
		int count = 1; // #3
		lookup_example(count); // unqualified count refers to #3
	}
	return count + ::count; // the first (unqualified) count refers to #2 ;
} // the second (qualified) count refers to #1
\end{lstlisting}

对于非限定名称的查找，最近增加了一项新的查找机制——除了常规的查找之外——有时可能要进行依赖参数的查找(ADL)。

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm}在C++98/C++03中，这也称为Koenig查找(或扩展Koenig查找)，以Andrew Koenig命名，他首先提出了这种机制的变体。
\end{tcolorbox}

在继续研究ADL之前，让我们用max()模板来触发这个机制:

\begin{lstlisting}[style=styleCXX]
template<typename T>
T max (T a, T b)
{
	return b < a ? a : b;
}
\end{lstlisting}

假设现在需要将此模板应用于定义在另一个命名空间中的类型:

\begin{lstlisting}[style=styleCXX]
namespace BigMath {
	class BigNumber {
		...
	};
	bool operator < (BigNumber const&, BigNumber const&);
	...
}

using BigMath::BigNumber;

void g (BigNumber const& a, BigNumber const& b)
{
	...
	BigNumber x = ::max(a,b);
	...
}
\end{lstlisting}

这里的问题是max()模板不知道BigMath名称空间，但是常规查找无法找到适用于BigNumber类型值的操作符<。如果没有一些特殊的规则，这将大大降低模板在C++名称空间中的适用性。ADL是对这些“特殊规则”的回答。

\subsubsubsection{13.2.1\hspace{0.2cm}ADL}


ADL主要适用于非限定名称，这些名称看起来像是在函数调用或操作符调用中命名非成员函数。如果在常规查找中，就不会发生ADL了

\begin{itemize}
\item 
成员函数的名称，

\item 
变量名，

\item 
类型的名称，或

\item 
块作用域函数声明的名称。
\end{itemize}

若要调用的函数名在括号内，则ADL也会受到抑制。

否则，若名称后面跟着用圆括号括起来的参数表达式列表，ADL将继续在与调用参数类型“相关”的名称空间和类中查找名称。这些关联的名称空间和关联类的精确定义将在后面给出，但它们可以认为是与给定类型相当直接相连的所有名称空间和类。例如，如果类型是指向类X的指针，那么相关的类和名称空间将包括X，以及X所属的任何名称空间或类。

对于给定类型的关联名称空间和关联类的精确定义由以下规则确定:

\begin{itemize}
\item 
对于内置类型，这是空集。

\item 
对于指针和数组类型，关联的名称空间和类的集合是基础类型的集合。

\item 
对于枚举类型，关联的命名空间是在其中声明枚举的命名空间。

\item 
对于类成员，外围类是关联类。

\item 
对于类类型(包括联合类型)，相关类的集合是类型本身、封闭类，以及任何直接和间接基类。关联名称空间的集合是在其中声明关联类的名称空间。如果类是类模板实例，则模板类型参数的类型以及声明模板模板参数的类和名称空间也包括在内。

\item 
对于函数类型，关联的名称空间和类集合包含与所有参数类型和返回类型关联的名称空间和类。

\item 
对于指向类X成员类型的指针，关联的命名空间和类集除了与成员类型关联的命名空间和类外，还包括与X关联的命名空间和类。(如果是指向成员函数类型的指针，那么参数和返回类型也可以起作用。)
\end{itemize}

然后，ADL在所有关联的名称空间中查找该名称，就好像该名称已经通过这些名称空间进行了限定一样(除非忽略using的指示)。下面的例子说明了这一点:

\noindent
\textit{details/adl.cpp}
\begin{lstlisting}[style=styleCXX]
#include <iostream>

namespace X {
	template<typename T> void f(T);
}

namespace N {
	using namespace X;
	enum E { e1 };
	void f(E) {
		std::cout << "N::f(N::E) called\n";
	}
}

void f(int)
{
	std::cout << "::f(int) called\n";
}

int main()
{
	::f(N::e1); // qualified function name: no ADL
	f(N::e1); // ordinary lookup finds ::f() and ADL finds N::f(),
} // the latter is preferred
\end{lstlisting}

Note that in this example, the using directive in namespace N is ignored when ADL is performed. Hence X::f() is never even a candidate for the call in main().

\subsubsubsection{13.2.2\hspace{0.2cm}Argument-Dependent Lookup of Friend Declarations}

A friend function declaration can be the first declaration of the nominated function. If this is the case, then the function is assumed to be declared in the nearest namespace scope (which may be the global scope) enclosing the class containing the friend declaration. However, such a friend declaration is not directly visible in that scope. Consider the following example:

\begin{lstlisting}[style=styleCXX]
template<typename T>
class C {
	...
	friend void f();
	friend void f(C<T> const&);
	...
};

void g (C<int>* p)
{
	f(); // is f() visible here?
	f(*p); // is f(C<int> const&) visible here?
}
\end{lstlisting}

If friend declarations were visible in the enclosing namespace, then instantiating a class template may make visible the declaration of ordinary functions. This would lead to surprising behavior: The call f() would result in a compilation error unless an instantiation of the class C occurred earlier in the program!

On the other hand, it can be useful to declare (and define) a function in a friend declaration only (see Section 21.2.1 on page 497 for a technique that relies on this behavior). Such a function can be found when the class of which they are a friend is among the associated classes considered by ADL.

Reconsider our last example. The call f() has no associated classes or namespaces because there are no arguments: It is an invalid call in our example. However, the call f(*p) does have the associated class C<int> (because this is the type of *p), and the global namespace is also associated (because this is the namespace in which the type of *p is declared). Therefore, the second friend function declaration could be found provided the class C<int> was actually fully instantiated prior to the call. To ensure this, it is assumed that a call involving a lookup for friends in associated classes actually causes the class to be instantiated (if not done already).

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm}Although this was clearly intended by those who wrote the C++ standard, it is not clearly spelled out in the standard.
\end{tcolorbox}

The ability of argument-dependent lookup to find friend declarations and definition is sometimes referred to as friend name injection. However, this term is somewhat misleading, because it is the name of a pre-standard C++ feature that did in fact “inject” the names of friend declarations into the enclosing scope, making them visible to normal name lookup. In our example above, this would mean that both calls would be well-formed. This chapter’s afternotes further detail the history of friend name injection.

\subsubsubsection{13.2.3\hspace{0.2cm}Injected Class Names}

The name of a class is injected inside the scope of that class itself and is therefore accessible as an unqualified name in that scope. (However, it is not accessible as a qualified name because this is the notation used to denote the constructors.) For example:

\noindent
\textit{details/adl.cpp}
\begin{lstlisting}[style=styleCXX]
#include <iostream>

int C;

class C {
private:
	int i[2];
public:
	static int f() {
		return sizeof(C);
	}
};

int f()
{
	return sizeof(C);
}

int main()
{
	std::cout << "C::f() = " << C::f() << ’,’
	<< " ::f() = " << ::f() << ’\n’;
}
\end{lstlisting}

The member function C::f() returns the size of type C, whereas the function ::f() returns the size of the variable C (in other words, the size of an int object).

Class templates also have injected class names. However, they’re stranger than ordinary injected class names: They can be followed by template arguments (in which case they are injected class template names), but if they are not followed by template arguments they represent the class with its parameters as its arguments (or, for a partial specialization, its specialization arguments) if the context expects a type, or a template if the context expects a template. This explains the following situation:

\begin{lstlisting}[style=styleCXX]
template<template<typename> class TT> class X {
};

template<typename T> class C {
	C* a; // OK: same as “C<T>* a;”
	C<void>& b; // OK
	X<C> c; // OK: C without a template argument list denotes the template C
	X<::C> d; // OK: ::C is not the injected class name and therefore always
			  // denotes the template
};
\end{lstlisting}

Note how the unqualified name refers to the injected name and is not considered the name of the template if it is not followed by a list of template arguments. To compensate, we can force the name of the template to be found by using the file scope qualifier ::.

The injected class name for a variadic template has an additional wrinkle: If the injected class name were directly formed by using the variadic template’s template parameters as the template arguments, the injected class name would contain template parameter packs that have not been expanded (see Section 12.4.1 on page 201 for details of pack expansion). Therefore, when forming the injected class name for a variadic template, the template argument that corresponds to a template parameter pack is a pack expansion whose pattern is that template parameter pack:

\begin{lstlisting}[style=styleCXX]
template<int I, typename... T> class V {
	V* a; // OK: same as “V<I, T...>* a;”
	V<0, void> b; // OK
};
\end{lstlisting}

\subsubsubsection{13.2.4\hspace{0.2cm}Current Instantiations}

The injected class name of a class or class template is effectively an alias for the type being defined. For a nontemplate class, this property is obvious, because the class itself is the only type with that name and in that scope. However, inside a class template or a nested class within a class template, each template instantiation produces a different type. This property is particularly interesting in that context, because it means that the injected class name refers to the same instantiation of the class template rather than some other specialization of that class template (the same holds for nested classes of class templates).

Within a class template, the injected class name or any type that is equivalent to the injected class name (including looking through type alias declarations) of any enclosing class or class template is said to refer to a current instantiation. Types that depend on a template parameter (i.e., dependent types) but do not refer to a current instantiation are said to refer to an unknown specialization, which may be instantiated from the same class template or some entirely different class template. The following example illustrates the difference:

\begin{lstlisting}[style=styleCXX]
template<typename T> class Node {
	using Type = T;
	Node* next; // Node refers to a current instantiation
	Node<Type>* previous; // Node<Type> refers to a current instantiation
	Node<T*>* parent; // Node<T*> refers to an unknown specialization
};
\end{lstlisting}

Identifying whether a type refers to a current instantiation can be confusing in the presence of nested classes and class templates. The injected class names of enclosing classes and class templates (or types equivalent to them) do refer to a current instantiation, while the names of other nested classes or class templates do not:

\begin{lstlisting}[style=styleCXX]
template<typename T> class C {
	using Type = T;
	struct I {
		C* c; // C refers to a current instantiation
		C<Type>* c2; // C<Type> refers to a current instantiation
		I* i; // I refers to a current instantiation
	};

	struct J {
		C* c; // C refers to a current instantiation
		C<Type>* c2; // C<Type> refers to a current instantiation
		I* i; // I refers to an unknown specialization,
			  // because I does not enclose J
		J* j; // J refers to a current instantiation
	};
};
\end{lstlisting}

When a type refers to a current instantiation, the contents of that instantiated class are guaranteed to be instantiated from the class template or nested class thereof that is currently being defined. This has implications for name lookup when parsing templates—the subject of our next section—but it also leads to an alternative, more game-like way to determine whether a type X within the definition of a class template refers to a current instantiation or an unknown specialization: If another programmer can write an explicit specialization (described in detail in Chapter 16) such that X refers to that specialization, then X refers to an unknown specialization. For example, consider the instantiation of the type C<int>::J in the context of the above example: We know the definition of C<T>::J used to instantiate the concrete type (since that’s the type we’re instantiating). Moreover, because an explicit specialization cannot specialize a template or member of a template without also specializing all of the enclosing templates or members, C<int> will be instantiated from the enclosing class definition. Hence, the references to J and C<int> (where Type is int) within J refer to a current instantiation. On the other hand, one could write an explicit specialization for C<int>::I as follows:

\begin{lstlisting}[style=styleCXX]
template<> struct C<int>::I {
	// definition of the specialization
};
\end{lstlisting}

Here, the specialization of C<int>::I provides a completely different definition than the one that was visible from the definition of C<T>::J, so the I inside the definition of C<T>::J refers to an unknown specialization.


