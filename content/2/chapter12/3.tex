
When instantiating a template, template parameters are substituted by template arguments. The arguments can be determined using several different mechanisms:

\begin{itemize}
\item 
Explicit template arguments: A template name can be followed by explicit template arguments enclosed in angle brackets. The resulting name is called a template-id.

\item 
Injected class name: Within the scope of a class template X with template parameters P1, P2, . . . , the name of that template (X) can be equivalent to the template-id X<P1, P2, . . . >. See Section 13.2.3 on page 221 for details.

\item 
Default template arguments: Explicit template arguments can be omitted from template instances if default template arguments are available. However, for a class or alias template, even if all template parameters have a default value, the (possibly empty) angle brackets must be provided.


\item 
Argument deduction: Function template arguments that are not explicitly specified may be deduced from the types of the function call arguments in a call. This is described in detail in Chapter 15. Deduction is also done in a few other situations. If all the template arguments can be deduced, no angle brackets need to be specified after the name of the function template. C++17 also introduces the ability to deduce class template arguments from the initializer of a variable declaration or functional-notation type conversion; see Section 15.12 on page 313 for a discussion.
\end{itemize}

\subsubsubsection{12.3.1\hspace{0.2cm}Function Template Arguments}

Template arguments for a function template can be specified explicitly, deduced from the way the template is used, or provided as a default template argument. For example:

\noindent
\textit{details/max.cpp}
\begin{lstlisting}[style=styleCXX]
template<typename T>
T max (T a, T b)
{
	return b < a ? a : b;
}

int main()
{
	::max<double>(1.0, -3.0); // explicitly specify template argument
	::max(1.0, -3.0); // template argument is implicitly deduced to be double
	::max<int>(1.0, 3.0); // the explicit <int> inhibits the deduction;
	// hence the result has type int
}
\end{lstlisting}

Some template arguments can never be deduced because their corresponding template parameter does not appear in a function parameter type or for some other reason (see Section 15.2 on page 271). The corresponding parameters are typically placed at the beginning of the list of template parameters so they can be specified explicitly while allowing the other arguments to be deduced. For example:

\noindent
\textit{details/implicit.cpp}
\begin{lstlisting}[style=styleCXX]
template<typename DstT, typename SrcT>
DstT implicit_cast (SrcT const& x) // SrcT can be deduced, but DstT cannot
{
	return x;
}

int main()
{
	double value = implicit_cast<double>(-1);
}
\end{lstlisting}

If we had reversed the order of the template parameters in this example (in other words, if we had written template<typename SrcT, typename DstT>), a call of implicit\_cast would have to specify both template arguments explicitly.

Moreover, such parameters can’t usefully be placed after a template parameter pack or appear in a partial specialization, because there would be no way to explicitly specify or deduce them.

\begin{lstlisting}[style=styleCXX]
template<typename ... Ts, int N>
void f(double (&)[N+1], Ts ... ps); // useless declaration because N
// cannot be specified or deduced
\end{lstlisting}

Because function templates can be overloaded, explicitly providing all the arguments for a function template may not be sufficient to identify a single function: In some cases, it identifies a set of functions. The following example illustrates a consequence of this observation:

\begin{lstlisting}[style=styleCXX]
template<typename Func, typename T>
void apply (Func funcPtr, T x)
{
	funcPtr(x);
}

template<typename T> void single(T);

template<typename T> void multi(T);
template<typename T> void multi(T*);

int main()
{
	apply(&single<int>, 3); // OK
	apply(&multi<int>, 7); // ERROR: no single multi<int>
}
\end{lstlisting}

In this example, the first call to apply() works because the type of the expression \&single<int> is unambiguous. As a result, the template argument value for the Func parameter is easily deduced. In the second call, however, \&multi<int> could be one of two different types and therefore Func cannot be deduced in this case.

Furthermore, it is possible that substituting template arguments in a function template results in an attempt to construct an invalid C++ type or expression. Consider the following overloaded function template (RT1 and RT2 are unspecified types):

\begin{lstlisting}[style=styleCXX]
template<typename T> RT1 test(typename T::X const*);
template<typename T> RT2 test(...);
\end{lstlisting}

The expression test<int> makes no sense for the first of the two function templates because type int has no member type X. However, the second template has no such problem. Therefore, the expression \&test<int> identifies the address of a single function. The fact that the substitution of int into the first template fails does not make the expression invalid. This SFINAE (substitution failure is not an error) principle is an important ingredient to make the overloading of function templates practical and is discussed in Section 8.4 on page 129 and Section 15.7 on page 284.

\subsubsubsection{12.3.2\hspace{0.2cm}Type Arguments}

Template type arguments are the “values” specified for template type parameters. Any type (including void, function types, reference types, etc.) can, in general, be used as a template argument, but their substitution for the template parameters must lead to valid constructs:

\begin{lstlisting}[style=styleCXX]
template<typename T>
void clear (T p)
{
	*p = 0; // requires that the unary * be applicable to T
}

int main()
{
	int a;
	clear(a); // ERROR: int doesn’t support the unary *
}
\end{lstlisting}

\subsubsubsection{12.3.3\hspace{0.2cm}Nontype Arguments}

Nontype template arguments are the values substituted for nontype parameters. Such a value must be one of the following things:

\begin{itemize}
\item 
Another nontype template parameter that has the right type.

\item
A compile-time constant value of integer (or enumeration) type. This is acceptable only if the corresponding parameter has a type that matches that of the value or a type to which the value can be implicitly converted without narrowing. For example, a char value can be provided for an int parameter, but 500 is not valid for an 8-bit char parameter.

\item 
The name of an external variable or function preceded by the built-in unary \& (“address of”) operator. For functions and array variables, \& can be left out. Such template arguments match nontype parameters of a pointer type. C++17 relaxed this requirement to permit any constantexpression that produces a pointer to a function or variable.

\item 
The previous kind of argument but without a leading \& operator is a valid argument for a nontype parameter of reference type. Here too, C++17 relaxed the constraint to permit any constantexpression glvalue for a function or variable.

\item 
A pointer-to-member constant; in other words, an expression of the form \&C::m where C is a class type and m is a nonstatic member (data or function). This matches nontype parameters of pointerto-member type only. And again, in C++17, the actual syntactic form is no longer constrained: Any constant-expression evaluating to a matching pointer-to-member constant is permitted.

\item 
A null pointer constant is a valid argument for a nontype parameter of pointer or pointer-tomember type.
\end{itemize}

For nontype parameters of integral type—probably the most common kind of nontype parameter—implicit conversions to the parameter type are considered. With the introduction of constexpr conversion functions in C++11, this means that the argument before conversion can have a class type.

Prior to C++17, when matching an argument to a parameter that is a pointer or reference, userdefined conversions (constructors for one argument and conversion operators) and derived-to-base conversions are not considered, even though in other circumstances they would be valid implicit conversions. Implicit conversions that make an argument more const and/or more volatile are fine.

Here are some valid examples of nontype template arguments:

\begin{lstlisting}[style=styleCXX]
template<typename T, T nontypeParam>
class C;

C<int, 33>* c1; // integer type

int a;
C<int*, &a>* c2; // address of an external variable

void f();
void f(int);
C<void (*)(int), f>* c3; // name of a function: overload resolution selects
						// f(int) in this case; the & is implied

template<typename T> void templ_func();
C<void(), &templ_func<double>>* c4; // function template instantiations are functions

struct X {
	static bool b;
	int n;
	onstexpr operator int() const { return 42; }
};

C<bool&, X::b>* c5; // static class members are acceptable variable/function names

C<int X::*, &X::n>* c6; // an example of a pointer-to-member constant

C<long, X{}>* c7; // OK: X is first converted to int via a constexpr conversion
// function and then to long via a standard integer conversion
\end{lstlisting}

A general constraint of template arguments is that a compiler or a linker must be able to express their value when the program is being built. Values that aren’t known until a program is run (e.g., the address of local variables) aren’t compatible with the notion that templates are instantiated when the program is built.

Even so, there are some constant values that are, perhaps surprisingly, not currently valid:

\begin{itemize}
\item 
Floating-point numbers

\item 
String literals
\end{itemize}

(Prior to C++11, null pointer constants were not permitted either.)

One of the problems with string literals is that two identical literals can be stored at two distinct addresses. An alternative (but cumbersome) way to express templates instantiated over constant strings involves introducing an additional variable to hold the string:

\begin{lstlisting}[style=styleCXX]
template<char const* str>
class Message {
	...
};

extern char const hello[] = "Hello World!";
char const hello11[] = "Hello World!";

void foo()
{
	static char const hello17[] = "Hello World!";
	
	Message<hello> msg03; // OK in all versions
	Message<hello11> msg11; // OK since C++11
	Message<hello17> msg17; // OK since C++17
}
\end{lstlisting}

The requirement is that a nontype template parameter declared as reference or pointer can be a constant expression with external linkage in all C++ versions, internal linkage since C++11, or any linkage since C++17.

See Section 17.2 on page 354 for a discussion of possible future changes in this area.

Here are a few other (less surprising) invalid examples:

\begin{lstlisting}[style=styleCXX]
template<typename T, T nontypeParam>
class C;

struct Base {
	int i;
} base;

struct Derived : public Base {
} derived;

C<Base*, &derived>* err1; // ERROR: derived-to-base conversions are not considered

C<int&, base.i>* err2; // ERROR: fields of variables aren’t considered to be variables

int a[10];
C<int*, &a[0]>* err3; // ERROR: addresses of array elements aren’t acceptable either
\end{lstlisting}


\subsubsubsection{12.3.4\hspace{0.2cm}Template Template Arguments}

A template template argument must generally be a class template or alias template with parameters that exactly match the parameters of the template template parameter it substitutes. Prior to C++17, default template arguments of a template template argument were ignored (but if the template template parameter has default arguments, they are considered during the instantiation of the template). C++17 relaxed the matching rule to just require that the template template parameter be at least as specialized (see Section 16.2.2 on page 330) as the  corresponding template template argument.

This makes the following example invalid prior to C++17:

\begin{lstlisting}[style=styleCXX]
#include <list>
	// declares in namespace std:
	// template<typename T, typename Allocator = allocator<T>>
	// class list;

template<typename T1, typename T2,
		template<typename> class Cont> // Cont expects one parameter
class Rel {
	...
};

Rel<int, double, std::list> rel; // ERROR before C++17: std::list has more than
								// one template parameter
\end{lstlisting}

The problem in this example is that the std::list template of the standard library has more than one parameter. The second parameter (which describes an allocator) has a default value, but prior to C++17, that is not considered when matching std::list to the Container parameter.

Variadic template template parameters are an exception to the pre-C++17 “exact match” rule described above and offer a solution to this limitation: They enable more general matching against template template arguments. A template template parameter pack can match zero or more template parameters of the same kind in the template template argument:

\begin{lstlisting}[style=styleCXX]
#include <list>

template<typename T1, typename T2,
		template<typename... > class Cont> // Cont expects any number of
class Rel { // type parameters
	...
};

Rel<int, double, std::list> rel; // OK: std::list has two template parameters
								// but can be used with one argument
\end{lstlisting}

Template parameter packs can only match template arguments of the same kind. For example, the following class template can be instantiated with any class template or alias template having only template type parameters, because the template type parameter pack passed there as TT can match zero or more template type parameters:

\begin{lstlisting}[style=styleCXX]
#include <list>
#include <map>
	// declares in namespace std:
	// template<typename Key, typename T,
	// typename Compare = less<Key>,
	// typename Allocator = allocator<pair<Key const, T>>>
	// class map;
#include <array>
	// declares in namespace std:
	// template<typename T, size_t N>
	// class array;
	
template<template<typename... > class TT>
class AlmostAnyTmpl {
};

AlmostAnyTmpl<std::vector> withVector; // two type parameters
AlmostAnyTmpl<std::map> withMap; // four type parameters
AlmostAnyTmpl<std::array> withArray; // ERROR: a template type parameter pack
									// doesn’t match a nontype template parameter
\end{lstlisting}

The fact that, prior to C++17, only the keyword class could be used to declare a template template parameter does not indicate that only class templates declared with the keyword class were allowed as substituting arguments. Indeed, struct, union, and alias templates are all valid arguments for a template template parameter (alias templates since C++11, when they were introduced). This is similar to the observation that any type can be used as an argument for a template type parameter declared with the keyword class.

\subsubsubsection{12.3.5\hspace{0.2cm}Equivalence}

Two sets of template arguments are equivalent when values of the arguments are identical one-forone. For type arguments, type aliases don’t matter: It is the type ultimately underlying the type alias declaration that is compared. For integer nontype arguments, the value of the argument is compared; how that value is expressed doesn’t matter. The following example illustrates this concept:

\begin{lstlisting}[style=styleCXX]
template<typename T, int I>
class Mix;

using Int = int;

Mix<int, 3*3>* p1;
Mix<Int, 4+5>* p2; // p2 has the same type as p1
\end{lstlisting}

(As is clear from this example, no template definition is needed to establish the equivalence of the template argument lists.)

In template-dependent contexts, however, the “value” of a template argument cannot always be established definitely, and the rules for equivalence become a little more complicated. Consider the following example:

\begin{lstlisting}[style=styleCXX]
template<int N> struct I {};

template<int M, int N> void f(I<M+N>); // #1
template<int N, int M> void f(I<N+M>); // #2

template<int M, int N> void f(I<N+M>); // #3 ERROR
\end{lstlisting}

Study declarations \#1 and \#2 carefully, and you’ll notice that by just renaming M and N to, respectively, N and M, you obtain the same declaration: The two are therefore equivalent and declare the same function template f. The expressions M+N and N+M in those two declarations are called equivalent.

Declaration \#3 is, however, subtly different: The order of the operands is inverted. That makes the expression N+M in \#3 not equivalent to either of the other two expressions. However, because the expression will produce the same result for any values of the template parameters involved, those expressions are called functionally equivalent. It is an error for templates to be declared in ways that differ only because the declarations include functionally equivalent expressions that are not actually equivalent. However, such an error need not be diagnosed by your compiler. That’s because some compilers may, for example, internally represent N+1+1 in exactly the same way as N+2, whereas other compilers may not. Rather than impose a specific implementation approach, the standard allows either one and requires programmers to be careful in this area.

A function generated from a function template is never equivalent to an ordinary function even though they may have the same type and the same name. This has two important consequences for class members:

\begin{enumerate}
\item
A function generated from a member function template never overrides a virtual function.

\item
A constructor generated from a constructor template is never a copy or move constructor.

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm}However, a constructor template can be a default constructor.
\end{tcolorbox}

Similarly, an assignment generated from an assignment template is never a copy-assignment or moveassignment operator. (However, this is less prone to problems because implicit calls of copyassignment or move-assignment operators are less common.)
\end{enumerate}

This can be good and bad. See Section 6.2 on page 95 and Section 6.4 on page 102 for details.











