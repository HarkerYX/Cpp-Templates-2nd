

在上一节中，了解了名称相同的两个函数模板可以共存，即使以相同的参数类型实例化。下面是另一个例子:

\hspace*{\fill} \\ %插入空行
\noindent
\textit{deduce/funcoverload1.hpp}
\begin{lstlisting}[style=styleCXX]
template<typename T>
int f(T)
{
	return 1;
}

template<typename T>
int f(T*)
{
	return 2;
}
\end{lstlisting}

第一个模板中用int*替换T时，得到的函数与在第二个模板中用int替换T得到的函数具有相同的参数(和返回)类型。不仅这些模板可以共存，它们各自的实例化也可以共存，即使具有相同的参数和返回类型。

下面演示了如何使用显式模板参数语法调用这两个生成的函数(假设前面对模板进行了声明):

\hspace*{\fill} \\ %插入空行
\noindent
\textit{deduce/funcoverload1.cpp}
\begin{lstlisting}[style=styleCXX]
#include <iostream>
#include "funcoverload1.hpp"
int main()
{
	std::cout << f<int*>((int*)nullptr); // calls f<T>(T)
	std::cout << f<int>((int*)nullptr); // calls f<T>(T*)
}
\end{lstlisting}

程序输出：

\begin{tcblisting}{commandshell={}}
12
\end{tcblisting}

为了澄清这一点，这里详细分析一下f<int*>((int*)nullptr)的调用。语法f<int*>()表示用int*替换模板f()的第一个模板参数。这里不止一个模板f()，因此创建了一个重载集，其中包含从模板生成的两个函数:f<int*>(int*)(从第一个模板生成)和f<int*>(int**)(从第二个模板生成)。调用(int*)nullptr的参数类型为int*，这只匹配从第一个模板生成的函数。

对于第二次调用，创建的重载集包含f<int>(int)(从第一个模板生成)和f<int>(int*)(从第二个模板生成)，因此只有第二个模板匹配。

\subsubsubsection{16.2.1\hspace{0.2cm}签名}

如果两个函数有不同的签名，可以在一个程序中共存。函数签名的定义如下所示:

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm}这个定义与C++标准中给出的定义不同，但其结果等价。
\end{tcolorbox}

\begin{enumerate}
\item 
函数的非限定名(或生成函数模板的名称)

\item 
名称在类或命名空间作用域中，若该名称具有内部链接，则声明为该名称的翻译单元

\item 
函数的const、volatile或const volatile限定符(若具有这样限定符的成员函数)

\item 
函数的\&或\&\&限定符(若具有这样限定符的成员函数)

\item 
函数参数的类型(若函数是由函数模板生成，则指的是替换前的模板参数)

\item 
函数是由函数模板生成的，则包括它的函数返回类型

\item 
如果函数是从函数模板中生成，则包括模板参数和模板实参
\end{enumerate}

这意味着下面的模板和实例化体可以在一个程序中共存：

\begin{lstlisting}[style=styleCXX]
template<typename T1, typename T2>
void f1(T1, T2);

template<typename T1, typename T2>
void f1(T2, T1);

template<typename T>
long f2(T);

template<typename T>
char f2(T);
\end{lstlisting}

然而，当定义在相同的作用域中时，因为实例化会产生重载歧义，所以不能总一起使用。例如，调用f2(42)对于上面声明的模板会产生歧义：

\begin{lstlisting}[style=styleCXX]
#include <iostream>
template<typename T1, typename T2>
void f1(T1, T2)
{
	std::cout << "f1(T1, T2)\n";
}

template<typename T1, typename T2>
void f1(T2, T1)
{
	std::cout << "f1(T2, T1)\n";
}

// fine so far
int main()
{
	f1<char, char>(’a’, ’b’); // ERROR: ambiguous
}
\end{lstlisting}

这里，函数

\begin{lstlisting}[style=styleCXX]
f1<T1 = char, T2 = char>(T1, T2)
\end{lstlisting}

可以与下面函数共存

\begin{lstlisting}[style=styleCXX]
f1<T1 = char, T2 = char>(T2, T1)
\end{lstlisting}

但是重载解析永远无法判断出哪一个更合适。如果模板在不同的编译单元中出现，这两个实例化体实际上可以在同一个程序中共存(并且，链接器不会抱怨重复的定义，这是因为实例化的签名是有区别的):

\begin{lstlisting}[style=styleCXX]
// translation unit 1:
#include <iostream>

template<typename T1, typename T2>
void f1(T1, T2)
{
	std::cout << "f1(T1, T2)\n";
}

void g()
{
	f1<char, char>(’a’, ’b’);
}

// translation unit 2:
#include <iostream>

template<typename T1, typename T2>
void f1(T2, T1)
{
	std::cout << "f1(T2, T1)\n";
}

extern void g(); // defined in translation unit 1

int main()
{
	f1<char, char>(’a’, ’b’);
	g();
}
\end{lstlisting}

该程序有效，其输出如下：

\begin{tcblisting}{commandshell={}}
f1(T2, T1)
f1(T1, T2)
\end{tcblisting}

\subsubsubsection{16.2.2\hspace{0.2cm}重载函数模板的部分排序}

Reconsider our earlier example: We found that after substituting the given template argument lists (<int*> and <int>), overload resolution ended up selecting the right function to call:

\begin{tcblisting}{commandshell={}}
std::cout << f<int*>((int*)nullptr); // calls f<T>(T)
std::cout << f<int>((int*)nullptr); // calls f<T>(T*)
\end{tcblisting}

However, a function is selected even when explicit template arguments are not provided. In this case, template argument deduction comes into play. Let’s slightly modify function main() in the previous example to discuss this mechanism:

\hspace*{\fill} \\ %插入空行
\noindent
\textit{deduce/funcoverload2.cpp}
\begin{lstlisting}[style=styleCXX]
#include <iostream>

template<typename T>
int f(T)
{
	return 1;
}

template<typename T>
int f(T*)
{
	return 2;
}

int main()
{
	std::cout << f(0); // calls f<T>(T)
	std::cout << f(nullptr); // calls f<T>(T)
	std::cout << f((int*)nullptr); // calls f<T>(T*)
}
\end{lstlisting}

Consider the first call, f(0): The type of the argument is int, which matches the type of the parameter of the first template if we substitute T with int. However, the parameter type of the second template is always a pointer and, hence, after deduction, only an instance generated from the first template is a candidate for the call. In this case overload resolution is trivial.

The same applies to the second call: f(nullptr): The type of the argument is std::nullptr\_t, which again only matches for the first template.

The third call (f((int*)nullptr)) is more interesting: Argument deduction succeeds for both templates, yielding the functions f<int*>(int*) and f<int>(int*). From a traditional overload resolution perspective, both are equally good functions to call with an int* argument, which would suggest that the call is ambiguous (see Appendix C). However, in this sort of case, an additional overload resolution criterion comes into play: The function generated from the more specialized template is selected. Here (as we see shortly), the second template is considered more specialized and thus the output of our example is

\begin{tcblisting}{commandshell={}}
112
\end{tcblisting}

\subsubsubsection{16.2.3\hspace{0.2cm}Formal Ordering Rules}

In our last example, it may seem very intuitive that the second template is more special than the first because the first can accommodate just about any argument type, whereas the second allows only pointer types. However, other examples are not necessarily as intuitive. In what follows, we describe the exact procedure to determine whether one function template participating in an overload set is more specialized than the other. Note that these are partial ordering rules: It is possible that given two templates, neither can be considered more specialized than the other. If overload resolution must select between two such templates, no decision can be made, and the program contains an ambiguity error.

Let’s assume we are comparing two identically named function templates that seem viable for a given function call. Overload resolution is decided as follows:


\begin{itemize}
\item 
Function call parameters that are covered by a default argument and ellipsis parameters that are not used are ignored in what follows.

\item 
We then synthesize two artificial lists of argument types (or for conversion function templates, a return type) by substituting every template parameter as follows:

\begin{enumerate}
\item 
Replace each template type parameter with a unique invented type.

\item 
Replace each template template parameter with a unique invented class template.

\item 
Replace each nontype template parameter with a unique invented value of the appropriate type.
\end{enumerate}

(Types, templates, and values that are invented in this context are distinct from any other types, templates, or values that either the programmer used or the compiler synthesized in other contexts.)

\item 
If template argument deduction of the second template against the first synthesized list of argument types succeeds with an exact match, but not vice versa, then the first template is more specialized than the second. Conversely, if template argument deduction of the first template against the second synthesized list of argument types succeeds with an exact match, but not vice versa, then the second template is more specialized than the first. Otherwise (either no deduction succeeds or both succeed), there is no ordering between the two templates.
\end{itemize}

Let’s make this concrete by applying it to the two templates in our last example. From these two templates, we synthesize two lists of argument types by replacing the template parameters as described earlier: (A1) and (A2*) (where A1 and A2 are unique made up types). Clearly, deduction of the first template against the second list of argument types succeeds by substituting A2* for T. However, there is no way to make T* of the second template match the nonpointer type A1 in the first list. Hence, we formally conclude that the second template is more specialized than the first.

Consider a more intricate example involving multiple function parameters:

\begin{lstlisting}[style=styleCXX]
template<typename T>
void t(T*, T const* = nullptr, ...);

template<typename T>
void t(T const*, T*, T* = nullptr);

void example(int* p)
{
	t(p, p);
}
\end{lstlisting}

First, because the actual call does not use the ellipsis parameter for the first template and the last parameter of the second template is covered by its default argument, these parameters are ignored in the partial ordering. Note that the default argument of the first template is not used; hence the corresponding parameter participates in the ordering.

The synthesized lists of argument types are (A1*, A1 const*) and (A2 const*, A2*). Template argument deduction of (A1*, A1 const*) versus the second template actually succeeds with the substitution of T with A1 const, but the resulting match is not exact because a qualification adjustment is needed to call t<A1 const>(A1 const*, A1 const*, A1 const* = 0) with arguments of types (A1*, A1 const*). Similarly, no exact match can be found by deducing template arguments for the first template from the argument type list (A2 const*, A2*). Therefore, there is no ordering relationship between the two templates, and the call is ambiguous.

The formal ordering rules generally result in the intuitive selection of function templates. Once in a while, however, an example comes up for which the rules do not select the intuitive choice. It is therefore possible that the rules will be revised to accommodate those examples in the future.

\subsubsubsection{16.2.4\hspace{0.2cm}Templates and Nontemplates}

Function templates can be overloaded with nontemplate functions. All else being equal, the nontemplate function is preferred in selecting the actual function being called. The following example illustrates this:

\hspace*{\fill} \\ %插入空行
\noindent
\textit{details/nontmpl1.cpp}
\begin{lstlisting}[style=styleCXX]
#include <string>
#include <iostream>

template<typename T>
std::string f(T)
{
	return "Template";
}

std::string f(int&)
{
	return "Nontemplate";
}

int main()
{
	int x = 7;
	std::cout << f(x) << ’\n’; // prints: Nontemplate
}
\end{lstlisting}

This outputs

\begin{tcblisting}{commandshell={}}
Nontemplate
\end{tcblisting}

However, when const and reference qualifiers differ, priorities for overload resolution can change. For example:

\hspace*{\fill} \\ %插入空行
\noindent
\textit{details/nontmpl2.cpp}
\begin{lstlisting}[style=styleCXX]
#include <string>
#include <iostream>

template<typename T>
std::string f(T&)
{
	return "Template";
}

std::string f(int const&)
{
	return "Nontemplate";
}

int main()
{
	int x = 7;
	std::cout << f(x) << ’\n’; // prints: Template
	int const c = 7;
	std::cout << f(c) << ’\n’; // prints: Nontemplate
}
\end{lstlisting}

The program has the following output:

\begin{tcblisting}{commandshell={}}
Template
Nontemplate
\end{tcblisting}

Now, the function template f<>(T\&) is a better match when passing a nonconstant int. The reason is that for an int the instantiated f<>(int\&) is a better match than f(int const\&). Thus, the difference is not only the fact that one function is a template and the other is not. In that case the general rules of overload resolution apply (see Section C.2 on page 682). Only when calling f() for a int const, do both signatures have the same type int const\&, so that the nontemplate is preferred.

For this reason, it’s a good idea to declare the member function template as

\begin{lstlisting}[style=styleCXX]
template<typename T>
std::string f(T const&)
{
	return "Template";
}
\end{lstlisting}

Nevertheless, this effect can easily occur accidentally and cause surprising behavior when member functions are defined that accept the same arguments as copy or move constructors. For example:

\hspace*{\fill} \\ %插入空行
\noindent
\textit{details/tmplconstr.cpp}
\begin{lstlisting}[style=styleCXX]
#include <string>
#include <iostream>

class C {
	public:
	C() = default;
	C (C const&) {
		std::cout << "copy constructor\n";
	}
	C (C&&) {
		std::cout << "move constructor\n";
	}
	template<typename T>
	C (T&&) {
		std::cout << "template constructor\n";
	}
};

int main()
{
	C x;
	C x2{x}; // prints: template constructor
	C x3{std::move(x)}; // prints: move constructor
	C const c;
	C x4{c}; // prints: copy constructor
	C x5{std::move(c)}; // prints: template constructor
}
\end{lstlisting}

The program has the following output:

\begin{tcblisting}{commandshell={}}
template constructor
move constructor
copy constructor
template constructor
\end{tcblisting}

Thus, the member function template is a better match for copying a C than the copy constructor. And for std::move(c), which yields type C const\&\& (a type that is possible but usually doesn’t have meaningful semantics), the member function template also is a better match than the move constructor.

For this reason, usually you have to partially disable such member function templates when they might hide copy or move constructors. This is explained in Section 6.4 on page 99.


\subsubsubsection{16.2.5\hspace{0.2cm}Variadic Function Templates}

Variadic function templates (see Section 12.4 on page 200) require some special treatment during partial ordering, because deduction for a parameter pack (described in Section 15.5 on page 275) matches a single parameter to multiple arguments. This behavior introduces several interesting situations for function template ordering, illustrated by the following example:

\hspace*{\fill} \\ %插入空行
\noindent
\textit{details/variadicoverload.cpp}
\begin{lstlisting}[style=styleCXX]
#include <iostream>

template<typename T>
int f(T*)
{
	return 1;
}

template<typename... Ts>
int f(Ts...)
{
	return 2;
}

template<typename... Ts>
int f(Ts*...)
{
	return 3;
}

int main()
{
	std::cout << f(0, 0.0); // calls f<>(Ts...)
	std::cout << f((int*)nullptr, (double*)nullptr); // calls f<>(Ts*...)
	std::cout << f((int*)nullptr); // calls f<>(T*)
}
\end{lstlisting}

The output of this example, which we will discuss in a moment, is

\begin{tcblisting}{commandshell={}}
231
\end{tcblisting}

In the first call, f(0, 0.0), each of the function templates named f is considered. For the first function template, f(T*), deduction fails both because the template parameter T cannot be deduced and because there are more function arguments than parameters for this nonvariadic function template. The second function template, f(Ts...), is variadic: Deduction in this case compares the pattern of a function parameter pack (Ts) against against the types of the two arguments (int and double, respectively), deducing Ts to the sequence (int, double). For the third function template, f(Ts*...), deduction compares the pattern of the function parameter pack Ts* against each of the argument types. This deduction fails (Ts cannot be deduced), leaving only the second function template viable. Function template ordering is not required.

The second call, f((int*)nullptr, (double*)nullptr), is more interesting: Deduction fails for the first function template because there are more function arguments than parameters, but deduction succeeds for the second and third templates. Written explicitly, the resulting calls would be

\begin{lstlisting}[style=styleCXX]
f<int*,double*>((int*)nullptr, (double*)nullptr) // for second template
\end{lstlisting}

and

\begin{lstlisting}[style=styleCXX]
f<int,double>((int*)nullptr, (double*)nullptr) // for third template
\end{lstlisting}

Partial ordering then considers the second and third templates, both of which are variadic as follows: When applying the formal ordering rules described in Section 16.2.3 on page 331 to a variadic template, each template parameter pack is replaced by a single made-up type, class template, or value. For example, this means that the synthesized argument types for the second and third function templates are A1 and A2*, respectively, where A1 and A2 are unique, made-up types. Deduction of the second template against the third’s list of argument types succeeds by substituting the single-element sequence (A2*) for the parameter pack Ts. However, there is no way to make the pattern Ts* of the third template’s parameter pack match the nonpointer type A1, so the third function template (which accepts pointer arguments) is considered more specialized than the second function template (which accepts any arguments).

The third call, f((int*)nullptr), introduces a new wrinkle: Deduction succeeds for all three of the function templates, requiring partial ordering to compare a nonvariadic template to a variadic template. To illustrate, we compare the first and third function templates. Here, the synthesized argument types are A1* and A2*, where A1 and A2 are unique, made-up types. Deduction of the first template against the third’s synthesized argument list would normally succeed by substituting A2 for T. In the other direction, deduction of the third template against the first’s synthesized argument list succeeds by substituting the single-element sequence (A1) for the parameter pack Ts. Partial ordering between the first and third templates would normally result in an ambiguity. However, a special rule prohibits an argument that originally came from a function parameter pack (e.g., the third template’s parameter pack Ts*...) from matching a parameter that is not a parameter pack (the first template’s parameter T *). Hence, template deduction of the first template against the third’s synthesized argument list fails, and the first template is considered more specialized than the third. This special rule effectively considers nonvariadic templates (those with a fixed number of parameters) to be more specialized than variadic templates (with a variable number of parameters).

The rules described above apply equally to pack expansions that occur in types in the function signature. For example, we can wrap the parameters and arguments of each of the function templates in our previous example into a variadic class template Tuple to arrive at a similar example not involving function parameter packs:

\hspace*{\fill} \\ %插入空行
\noindent
\textit{details/tupleoverload.cpp}
\begin{lstlisting}[style=styleCXX]
#include <iostream>

template<typename... Ts> class Tuple
{
};

template<typename T>
int f(Tuple<T*>)
{
	return 1;
}

template<typename... Ts>
int f(Tuple<Ts...>)
{
	return 2;
}

template<typename... Ts>
int f(Tuple<Ts*...>)
{
	return 3;
}

int main()
{
	std::cout << f(Tuple<int, double>()); // calls f<>(Tuple<Ts...>)
	std::cout << f(Tuple<int*, double*>()); // calls f<>(Tuple<Ts*...>)
	std::cout << f(Tuple<int*>()); // calls f<>(Tuple<T*>)
}
\end{lstlisting}

Function template ordering considers the pack expansions in the template arguments to Tuple analogously to the function parameter packs in our previous example, resulting in the same output:

\begin{tcblisting}{commandshell={}}
231
\end{tcblisting}





















