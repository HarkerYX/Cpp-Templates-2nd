
重载函数模板的能力，结合部分排序规则来选择“最佳”匹配的函数模板，允许通用实现添加更多特化的模板，透明地调优代码以提高效率。但是，类模板和变量模板不能重载。相反，选择了另一种机制来支持类模板的透明定制:显式特化，指的是一种全特化的语言特性。它提供了一个模板的实现，可以完全替换模板参数:没有保留模板参数。类模板、函数模板和变量模板可以全特化。

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm}别名模板是唯一一种不能通过全特化或偏特化进行特化的模板。为了使模板别名的模板参数推导透明化，这个限制是必要的。参见第15.11节。
\end{tcolorbox}

在类定义体之外定义的类模板成员(即成员函数、嵌套类、静态数据成员和成员枚举类型)也可以这样做。

后面的一节中，将描述偏特化。这类似于全特化，不完全替换模板参数，而是在模板的替代实现中保留了一些参数。全特化和偏特化在源码中都是显式的，这就是为什么在讨论中避免使用显式特化这个术语。全特化和偏特化都不会引入全新的模板或模板实例，这些构造为已经在泛型(或非特化)模板中隐式声明实例提供了显式定义。这是一个相对重要的概念，也是与重载模板的关键区别。

\subsubsubsection{16.3.1\hspace{0.2cm}类模板全特化}

通过三个标记的序列引入了全特化:template、<和>。

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm}声明完整的函数模板特化也需要相同的前缀。C++早期设计不包括这个前缀，但是成员模板的添加需要额外的语法来消除复杂的特化歧义。
\end{tcolorbox}

此外，类名后面跟着声明特化的模板参数:

\begin{lstlisting}[style=styleCXX]
template<typename T>
class S {
	public:
	void info() {
		std::cout << "generic (S<T>::info())\n";
	}
};

template<>
class S<void> {
	public:
	void msg() {
		std::cout << "fully specialized (S<void>::msg())\n";
	}
};
\end{lstlisting}

全特化的实现不需要与泛型定义相关:这允许拥有不同名称的成员函数(info和msg)。其与泛型定义的关联，仅为类模板决定的名称。

指定的模板实参列表必须与模板形参列表对应，为模板类型参数指定非类型值是无效的。但是，对于带有默认模板实参的形参，模板实参是可选的:

\begin{lstlisting}[style=styleCXX]
template<typename T>
class Types {
	public:
	using I = int;
};

template<typename T, typename U = typename Types<T>::I>
class S; // #1
template<>
class S<void> { // #2
	public:
	void f();
};

template<> class S<char, char>; // #3

template<> class S<char, 0>; // ERROR: 0 cannot substitute U

int main()
{
	S<int>* pi; // OK: uses #1 , no definition needed
	S<int> e1; // ERROR: uses #1 , but no definition available
	S<void>* pv; // OK: uses #2
	S<void,int> sv; // OK: uses #2 , definition available
	S<void,char> e2; // ERROR: uses #1 , but no definition available
	S<char,char> e3; // ERROR: uses #3 , but no definition available
}

template<>
class S<char, char> { // definition for #3
};
\end{lstlisting}

正如这个示例，全特化(和模板)的声明不一定是定义。但当声明全特化时，对给定的模板参数集从不使用泛型定义。因此，如果需要定义但没有提供，程序就会出错。对于类模板特化，有时“前置声明”类型很有用，这可以构造相互依赖的类型。全特化声明与普通类声明相同(不是模板声明)，区别是语法和声明必须与前面的模板声明相匹配。因为不是模板声明，所以完整类模板特化的成员可以使用普通的类外成员定义语法来定义(换句话说，不能指定template<>的前缀):

\begin{lstlisting}[style=styleCXX]
template<typename T>
class S;
template<> class S<char**> {
	public:
	void print() const;
};

// the following definition cannot be preceded by template<>
void S<char**>::print() const
{
	std::cout << "pointer to pointer to char\n";
}
\end{lstlisting}

更复杂的例子可能会强化这一概念:

\begin{lstlisting}[style=styleCXX]
template<typename T>
class Outside {
	public:
	template<typename U>
	class Inside {
	};
};

template<>
class Outside<void> {
	// there is no special connection between the following nested class
	// and the one defined in the generic template
	template<typename U>
	class Inside {
		private:
		static int count;
	};
};

// the following definition cannot be preceded by template<>
template<typename U>
int Outside<void>::Inside<U>::count = 1;
\end{lstlisting}

A full specialization is a replacement for the instantiation of a certain generic template, and it is not valid to have both the explicit and the generated versions of a template present in the same program. An attempt to use both in the same file is usually caught by a compiler:

\begin{lstlisting}[style=styleCXX]
template<typename T>
class Invalid {
};

Invalid<double> x1; // causes the instantiation of Invalid<double>

template<>
class Invalid<double>; // ERROR: Invalid<double> already instantiated
\end{lstlisting}

Unfortunately, if the uses occur in different translation units, the problem may not be caught so easily. The following invalid C++ example consists of two files and compiles and links on many implementations, but it is invalid and dangerous:

\begin{lstlisting}[style=styleCXX]
// Translation unit 1:
template<typename T>
class Danger {
	public:
	enum { max = 10 };
};

char buffer[Danger<void>::max]; // uses generic value

extern void clear(char*);

int main()
{
	clear(buffer);
}

// Translation unit 2:
template<typename T>
class Danger;

template<>
class Danger<void> {
	public:
	enum { max = 100 };
};

void clear(char* buf)
{
	// mismatch in array bound:
	for (int k = 0; k<Danger<void>::max; ++k) {
		buf[k] = ’\0’;
	}
}
\end{lstlisting}

This example is clearly contrived to keep it short, but it illustrates that care must be taken to ensure that the declaration of the specialization is visible to all the users of the generic template. In practical terms, this means that a declaration of the specialization should normally follow the declaration of the template in its header file. When the generic implementation comes from an external source (such that the corresponding header files should not be modified), this is not necessarily practical, but it may be worth creating a header including the generic template followed by declarations of the specializations to avoid these hard-to-find errors. We find that, in general, it is better to avoid specializing templates coming from an external source unless it is clearly marked as being designed for that purpose.

\subsubsubsection{16.3.2\hspace{0.2cm}函数模板全特化}

The syntax and principles behind (explicit) full function template specialization are much the same as those for full class template specialization, but overloading and argument deduction come into play.

The full specialization declaration can omit explicit template arguments when the template being specialized can be determined via argument deduction (using as argument types the parameter types provided in the declaration) and partial ordering. For example:

\begin{lstlisting}[style=styleCXX]
template<typename T>
int f(T) // #1
{
	return 1;
}

template<typename T>
int f(T*) // #2
{
	return 2;
}

template<> int f(int) // OK: specialization of #1
{
	return 3;
}

template<> int f(int*) // OK: specialization of #2
{
	return 4;
}
\end{lstlisting}

A full function template specialization cannot include default argument values. However, any default arguments that were specified for the template being specialized remain applicable to the explicit specialization:

\begin{lstlisting}[style=styleCXX]
template<typename T>
int f(T, T x = 42)
{
	return x;
}

template<> int f(int, int = 35) // ERROR
{
	return 0;
}
\end{lstlisting}

(That’s because a full specialization provides an alternative definition, but not an alternative declaration. At the point of a call to a function template, the call is entirely resolved based on the function template.)

A full specialization is in many ways similar to a normal declaration (or rather, a normal redeclaration). In particular, it does not declare a template, and therefore only one definition of a noninline full function template specialization should appear in a program. However, we must still ensure that a declaration of the full specialization follows the template to prevent attempts at using the function generated from the template. The declarations for a template g() and one full specialization would therefore typically be organized in two files as follows:

\begin{itemize}
\item 
The interface file contains the definitions of primary templates and partial specializations but declares only the full specializations:

\begin{lstlisting}[style=styleCXX]
#ifndef TEMPLATE_G_HPP
#define TEMPLATE_G_HPP

// template definition should appear in header file:
template<typename T>
int g(T, T x = 42)
{
	return x;
}

// specialization declaration inhibits instantiations of the template;
// definition should not appear here to avoid multiple definition errors
template<> int g(int, int y);

#endif // TEMPLATE_G_HPP
\end{lstlisting}

\item 
The corresponding implementation file defines the full specialization:

\begin{lstlisting}[style=styleCXX]
#include "template_g.hpp"
template<> int g(int, int y)
{
	return y/2;
}
\end{lstlisting}
\end{itemize}

Alternatively, the specialization could be made inline, in which case its definition can be (and should be) placed in the header file.

\subsubsubsection{16.3.3\hspace{0.2cm}变量模板全特化}

Variable templates can also be fully specialized. By now, the syntax should be intuitive:

\begin{lstlisting}[style=styleCXX]
template<typename T> constexpr std::size_t SZ = sizeof(T);

template<> constexpr std::size_t SZ<void> = 0;
\end{lstlisting}

Clearly, the specialization can provide an initializer that is distinct from that resulting from the template. Interestingly, a variable template specialization is not required to have a type matching that of the template being specialized:

\begin{lstlisting}[style=styleCXX]
template<typename T> typename T::iterator null_iterator;

template<> BitIterator null_iterator<std::bitset<100>>;
// BitIterator doesn’t match T::iterator, and that is fine
\end{lstlisting}

\subsubsubsection{16.3.4\hspace{0.2cm}成员全特化}

Not only member templates, but also ordinary static data members and member functions of class templates, can be fully specialized. The syntax requires template<> prefix for every enclosing class template. If a member template is being specialized, a template<> must also be added to denote that it is being specialized. To illustrate the implications of this, let’s assume the following declarations:

\begin{lstlisting}[style=styleCXX]
template<typename T>
class Outer { // #1
	public:
	template<typename U>
	class Inner { // #2
		private:
		static int count; // #3
	};
	static int code; // #4
	void print() const { // #5
		std::cout << "generic";
	}
};

template<typename T>
int Outer<T>::code = 6; // #6

template<typename T> template<typename U>
int Outer<T>::Inner<U>::count = 7; // #7

template<>
class Outer<bool> { // #8
	public:
	template<typename U>
	class Inner { // #9
		private:
		static int count; // #10
	};
	void print() const { // #11
	}
};
\end{lstlisting}

The ordinary members code at point \#4 and print() at point \#5 of the generic Outer template \#1 have a single enclosing class template and hence need one template<> prefix to specialize them fully for a specific set of template arguments:

\begin{lstlisting}[style=styleCXX]
template<>
int Outer<void>::code = 12;

template<>
void Outer<void>::print() const
{
	std::cout << "Outer<void>";
}
\end{lstlisting}

These definitions are used over the generic ones at points \#4 and \#5 for class Outer<void>, but other members of class Outer<void> are still generated from the template at point \#1 . Note that after these declarations, it is no longer valid to provide an explicit specialization for Outer<void>.

Just as with full function template specializations, we need a way to declare the specialization of an ordinary member of a class template without specifying a definition (to prevent multiple definitions). Although nondefining out-of-class declarations are not allowed in C++ for member functions and static data members of ordinary classes, they are fine when specializing members of class templates. The previous definitions could be declared with

\begin{lstlisting}[style=styleCXX]
template<>
int Outer<void>::code;

template<>
void Outer<void>::print() const;
\end{lstlisting}

The attentive reader might point out that the nondefining declaration of the full specialization of Outer<void>::code looks exactly like a definition to be initialized with a default constructor. This is indeed so, but such declarations are always interpreted as nondefining declarations. For a full specialization of a static data member with a type that can only be initialized using a default constructor, we must resort to initializer list syntax. Given the following:

\begin{lstlisting}[style=styleCXX]
class DefaultInitOnly {
	public:
	DefaultInitOnly() = default;
	DefaultInitOnly(DefaultInitOnly const&) = delete;
};

template<typename T>
class Statics {
	private:
	static T sm;
};
\end{lstlisting}

the following is a declaration:

\begin{lstlisting}[style=styleCXX]
template<>
DefaultInitOnly Statics<DefaultInitOnly>::sm;
\end{lstlisting}

while the following is a definition that calls the default constructor:

\begin{lstlisting}[style=styleCXX]
template<>
DefaultInitOnly Statics<DefaultInitOnly>::sm{};
\end{lstlisting}

Prior to C++11, this was not possible. Default initialization was thus not available for such specializations. Typically, an initializer copying a default value was used:

\begin{lstlisting}[style=styleCXX]
template<>
DefaultInitOnly Statics<DefaultInitOnly>::sm = DefaultInitOnly();
\end{lstlisting}

Unfortunately, for our example that was not possible because the copy constructor is deleted. However, C++17 introduced mandatory copy-elision rules, which make that alternative valid, because no copy constructor invocation is involved anymore.

The member template Outer<T>::Inner can also be specialized for a given template argument without affecting the other members of the specific instantiation of Outer<T>, for which we are specializing the member template. Again, because there is one enclosing template, we will need one template<> prefix. This results in code like the following

\begin{lstlisting}[style=styleCXX]
template<>
template<typename X>
class Outer<wchar_t>::Inner {
	public:
	static long count; // member type changed
};

template<>
	template<typename X>
	long Outer<wchar_t>::Inner<X>::count;
\end{lstlisting}

The template Outer<T>::Inner can also be fully specialized, but only for a given instance of Outer<T>. We now need two template<> prefixes: one because of the enclosing class and one because we’re fully specializing the (inner) template:

\begin{lstlisting}[style=styleCXX]
template<>
	template<>
	class Outer<char>::Inner<wchar_t> {
		public:
		enum { count = 1 };
	};

// the following is not valid C++:
// template<> cannot follow a template parameter list
template<typename X>
template<> class Outer<X>::Inner<void>; // ERROR
\end{lstlisting}

Contrast this with the specialization of the member template of Outer<bool>. Because the latter is already fully specialized, there is no enclosing template, and we need only one template<> prefix:

\begin{lstlisting}[style=styleCXX]
template<>
class Outer<bool>::Inner<wchar_t> {
	public:
	enum { count = 2 };
};
\end{lstlisting}
































