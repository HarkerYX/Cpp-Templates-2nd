
The ability to overload function templates, combined with the partial ordering rules to select the “best” matching function template, allows us to add more specialized templates to a generic implementation to tune code transparently for greater efficiency. However, class templates and variable templates cannot be overloaded. Instead, another mechanism was chosen to enable transparent customization of class templates: explicit specialization. The standard term explicit specialization refers to a language feature that we call full specialization instead. It provides an implementation for a template with template parameters that are fully substituted: No template parameters remain. Class templates, function templates, and variable templates can be fully specialized.

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm}Alias templates are the only form of template that cannot be specialized, either by a full specialization or a partial specialization. This restriction is necessary to make the use of template aliases transparent to the template argument deduction process Section 15.11 on page 312.
\end{tcolorbox}

So can members of class templates that may be defined outside the body of a class definition (i.e., member functions, nested classes, static data members, and member enumeration types).

In a later section, we will describe partial specialization. This is similar to full specialization, but instead of fully substituting the template parameters, some parameterization is left in the alternative implementation of a template. Full specializations and partial specializations are both equally “explicit” in our source code, which is why we avoid the term explicit specialization in our discussion. Neither full nor partial specialization introduces a totally new template or template instance. Instead, these constructs provide alternative definitions for instances that are already implicitly declared in the generic (or unspecialized) template. This is a relatively important conceptual observation, and it is a key difference with overloaded templates.

\subsubsubsection{16.3.1\hspace{0.2cm}Full Class Template Specialization}

A full specialization is introduced with a sequence of three tokens: template, <, and >.

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm}The same prefix is also needed to declare full function template specializations. Earlier designs of the C++ language did not include this prefix, but the addition of member templates required additional syntax to disambiguate complex specialization cases.
\end{tcolorbox}

In addition, the class name is followed by the template arguments for which the specialization is declared. The following example illustrates this:

\begin{lstlisting}[style=styleCXX]
template<typename T>
class S {
	public:
	void info() {
		std::cout << "generic (S<T>::info())\n";
	}
};

template<>
class S<void> {
	public:
	void msg() {
		std::cout << "fully specialized (S<void>::msg())\n";
	}
};
\end{lstlisting}

Note how the implementation of the full specialization does not need to be related in any way to the generic definition: This allows us to have member functions of different names (info versus msg). The connection is solely determined by the name of the class template.

The list of specified template arguments must correspond to the list of template parameters. For example, it is not valid to specify a nontype value for a template type parameter. However, template arguments for parameters with default template arguments are optional:

\begin{lstlisting}[style=styleCXX]
template<typename T>
class Types {
	public:
	using I = int;
};

template<typename T, typename U = typename Types<T>::I>
class S; // #1
template<>
class S<void> { // #2
	public:
	void f();
};

template<> class S<char, char>; // #3

template<> class S<char, 0>; // ERROR: 0 cannot substitute U

int main()
{
	S<int>* pi; // OK: uses #1 , no definition needed
	S<int> e1; // ERROR: uses #1 , but no definition available
	S<void>* pv; // OK: uses #2
	S<void,int> sv; // OK: uses #2 , definition available
	S<void,char> e2; // ERROR: uses #1 , but no definition available
	S<char,char> e3; // ERROR: uses #3 , but no definition available
}

template<>
class S<char, char> { // definition for #3
};
\end{lstlisting}

As this example also shows, declarations of full specializations (and of templates) do not necessarily have to be definitions. However, when a full specialization is declared, the generic definition is never used for the given set of template arguments. Hence, if a definition is needed but none is provided, the program is in error. For class template specialization, it is sometimes useful to “forward declare” types so that mutually dependent types can be constructed. A full specialization declaration is identical to a normal class declaration in this way (it is not a template declaration). The only differences are the syntax and the fact that the declaration must match a previous template declaration. Because it is not a template declaration, the members of a full class template specialization can be defined using the ordinary out-of-class member definition syntax (in other words, the template<> prefix cannot be specified):

\begin{lstlisting}[style=styleCXX]
template<typename T>
class S;
template<> class S<char**> {
	public:
	void print() const;
};

// the following definition cannot be preceded by template<>
void S<char**>::print() const
{
	std::cout << "pointer to pointer to char\n";
}
\end{lstlisting}

A more complex example may reinforce this notion:

\begin{lstlisting}[style=styleCXX]
template<typename T>
class Outside {
	public:
	template<typename U>
	class Inside {
	};
};

template<>
class Outside<void> {
	// there is no special connection between the following nested class
	// and the one defined in the generic template
	template<typename U>
	class Inside {
		private:
		static int count;
	};
};

// the following definition cannot be preceded by template<>
template<typename U>
int Outside<void>::Inside<U>::count = 1;
\end{lstlisting}

A full specialization is a replacement for the instantiation of a certain generic template, and it is not valid to have both the explicit and the generated versions of a template present in the same program. An attempt to use both in the same file is usually caught by a compiler:

\begin{lstlisting}[style=styleCXX]
template<typename T>
class Invalid {
};

Invalid<double> x1; // causes the instantiation of Invalid<double>

template<>
class Invalid<double>; // ERROR: Invalid<double> already instantiated
\end{lstlisting}

Unfortunately, if the uses occur in different translation units, the problem may not be caught so easily. The following invalid C++ example consists of two files and compiles and links on many implementations, but it is invalid and dangerous:

\begin{lstlisting}[style=styleCXX]
// Translation unit 1:
template<typename T>
class Danger {
	public:
	enum { max = 10 };
};

char buffer[Danger<void>::max]; // uses generic value

extern void clear(char*);

int main()
{
	clear(buffer);
}

// Translation unit 2:
template<typename T>
class Danger;

template<>
class Danger<void> {
	public:
	enum { max = 100 };
};

void clear(char* buf)
{
	// mismatch in array bound:
	for (int k = 0; k<Danger<void>::max; ++k) {
		buf[k] = ’\0’;
	}
}
\end{lstlisting}

This example is clearly contrived to keep it short, but it illustrates that care must be taken to ensure that the declaration of the specialization is visible to all the users of the generic template. In practical terms, this means that a declaration of the specialization should normally follow the declaration of the template in its header file. When the generic implementation comes from an external source (such that the corresponding header files should not be modified), this is not necessarily practical, but it may be worth creating a header including the generic template followed by declarations of the specializations to avoid these hard-to-find errors. We find that, in general, it is better to avoid specializing templates coming from an external source unless it is clearly marked as being designed for that purpose.

\subsubsubsection{16.3.2\hspace{0.2cm}Full Function Template Specialization}

The syntax and principles behind (explicit) full function template specialization are much the same as those for full class template specialization, but overloading and argument deduction come into play.

The full specialization declaration can omit explicit template arguments when the template being specialized can be determined via argument deduction (using as argument types the parameter types provided in the declaration) and partial ordering. For example:

\begin{lstlisting}[style=styleCXX]
template<typename T>
int f(T) // #1
{
	return 1;
}

template<typename T>
int f(T*) // #2
{
	return 2;
}

template<> int f(int) // OK: specialization of #1
{
	return 3;
}

template<> int f(int*) // OK: specialization of #2
{
	return 4;
}
\end{lstlisting}

A full function template specialization cannot include default argument values. However, any default arguments that were specified for the template being specialized remain applicable to the explicit specialization:

\begin{lstlisting}[style=styleCXX]
template<typename T>
int f(T, T x = 42)
{
	return x;
}

template<> int f(int, int = 35) // ERROR
{
	return 0;
}
\end{lstlisting}

(That’s because a full specialization provides an alternative definition, but not an alternative declaration. At the point of a call to a function template, the call is entirely resolved based on the function template.)

A full specialization is in many ways similar to a normal declaration (or rather, a normal redeclaration). In particular, it does not declare a template, and therefore only one definition of a noninline full function template specialization should appear in a program. However, we must still ensure that a declaration of the full specialization follows the template to prevent attempts at using the function generated from the template. The declarations for a template g() and one full specialization would therefore typically be organized in two files as follows:

\begin{itemize}
\item 
The interface file contains the definitions of primary templates and partial specializations but declares only the full specializations:

\begin{lstlisting}[style=styleCXX]
#ifndef TEMPLATE_G_HPP
#define TEMPLATE_G_HPP

// template definition should appear in header file:
template<typename T>
int g(T, T x = 42)
{
	return x;
}

// specialization declaration inhibits instantiations of the template;
// definition should not appear here to avoid multiple definition errors
template<> int g(int, int y);

#endif // TEMPLATE_G_HPP
\end{lstlisting}

\item 
The corresponding implementation file defines the full specialization:

\begin{lstlisting}[style=styleCXX]
#include "template_g.hpp"
template<> int g(int, int y)
{
	return y/2;
}
\end{lstlisting}
\end{itemize}

Alternatively, the specialization could be made inline, in which case its definition can be (and should be) placed in the header file.

\subsubsubsection{16.3.3\hspace{0.2cm}Full Variable Template Specialization}

Variable templates can also be fully specialized. By now, the syntax should be intuitive:

\begin{lstlisting}[style=styleCXX]
template<typename T> constexpr std::size_t SZ = sizeof(T);

template<> constexpr std::size_t SZ<void> = 0;
\end{lstlisting}

Clearly, the specialization can provide an initializer that is distinct from that resulting from the template. Interestingly, a variable template specialization is not required to have a type matching that of the template being specialized:

\begin{lstlisting}[style=styleCXX]
template<typename T> typename T::iterator null_iterator;

template<> BitIterator null_iterator<std::bitset<100>>;
// BitIterator doesn’t match T::iterator, and that is fine
\end{lstlisting}

\subsubsubsection{16.3.4\hspace{0.2cm}Full Member Specialization}

Not only member templates, but also ordinary static data members and member functions of class templates, can be fully specialized. The syntax requires template<> prefix for every enclosing class template. If a member template is being specialized, a template<> must also be added to denote that it is being specialized. To illustrate the implications of this, let’s assume the following declarations:

\begin{lstlisting}[style=styleCXX]
template<typename T>
class Outer { // #1
	public:
	template<typename U>
	class Inner { // #2
		private:
		static int count; // #3
	};
	static int code; // #4
	void print() const { // #5
		std::cout << "generic";
	}
};

template<typename T>
int Outer<T>::code = 6; // #6

template<typename T> template<typename U>
int Outer<T>::Inner<U>::count = 7; // #7

template<>
class Outer<bool> { // #8
	public:
	template<typename U>
	class Inner { // #9
		private:
		static int count; // #10
	};
	void print() const { // #11
	}
};
\end{lstlisting}

The ordinary members code at point \#4 and print() at point \#5 of the generic Outer template \#1 have a single enclosing class template and hence need one template<> prefix to specialize them fully for a specific set of template arguments:

\begin{lstlisting}[style=styleCXX]
template<>
int Outer<void>::code = 12;

template<>
void Outer<void>::print() const
{
	std::cout << "Outer<void>";
}
\end{lstlisting}

These definitions are used over the generic ones at points \#4 and \#5 for class Outer<void>, but other members of class Outer<void> are still generated from the template at point \#1 . Note that after these declarations, it is no longer valid to provide an explicit specialization for Outer<void>.

Just as with full function template specializations, we need a way to declare the specialization of an ordinary member of a class template without specifying a definition (to prevent multiple definitions). Although nondefining out-of-class declarations are not allowed in C++ for member functions and static data members of ordinary classes, they are fine when specializing members of class templates. The previous definitions could be declared with

\begin{lstlisting}[style=styleCXX]
template<>
int Outer<void>::code;

template<>
void Outer<void>::print() const;
\end{lstlisting}

The attentive reader might point out that the nondefining declaration of the full specialization of Outer<void>::code looks exactly like a definition to be initialized with a default constructor. This is indeed so, but such declarations are always interpreted as nondefining declarations. For a full specialization of a static data member with a type that can only be initialized using a default constructor, we must resort to initializer list syntax. Given the following:

\begin{lstlisting}[style=styleCXX]
class DefaultInitOnly {
	public:
	DefaultInitOnly() = default;
	DefaultInitOnly(DefaultInitOnly const&) = delete;
};

template<typename T>
class Statics {
	private:
	static T sm;
};
\end{lstlisting}

the following is a declaration:

\begin{lstlisting}[style=styleCXX]
template<>
DefaultInitOnly Statics<DefaultInitOnly>::sm;
\end{lstlisting}

while the following is a definition that calls the default constructor:

\begin{lstlisting}[style=styleCXX]
template<>
DefaultInitOnly Statics<DefaultInitOnly>::sm{};
\end{lstlisting}

Prior to C++11, this was not possible. Default initialization was thus not available for such specializations. Typically, an initializer copying a default value was used:

\begin{lstlisting}[style=styleCXX]
template<>
DefaultInitOnly Statics<DefaultInitOnly>::sm = DefaultInitOnly();
\end{lstlisting}

Unfortunately, for our example that was not possible because the copy constructor is deleted. However, C++17 introduced mandatory copy-elision rules, which make that alternative valid, because no copy constructor invocation is involved anymore.

The member template Outer<T>::Inner can also be specialized for a given template argument without affecting the other members of the specific instantiation of Outer<T>, for which we are specializing the member template. Again, because there is one enclosing template, we will need one template<> prefix. This results in code like the following

\begin{lstlisting}[style=styleCXX]
template<>
template<typename X>
class Outer<wchar_t>::Inner {
	public:
	static long count; // member type changed
};

template<>
	template<typename X>
	long Outer<wchar_t>::Inner<X>::count;
\end{lstlisting}

The template Outer<T>::Inner can also be fully specialized, but only for a given instance of Outer<T>. We now need two template<> prefixes: one because of the enclosing class and one because we’re fully specializing the (inner) template:

\begin{lstlisting}[style=styleCXX]
template<>
	template<>
	class Outer<char>::Inner<wchar_t> {
		public:
		enum { count = 1 };
	};

// the following is not valid C++:
// template<> cannot follow a template parameter list
template<typename X>
template<> class Outer<X>::Inner<void>; // ERROR
\end{lstlisting}

Contrast this with the specialization of the member template of Outer<bool>. Because the latter is already fully specialized, there is no enclosing template, and we need only one template<> prefix:

\begin{lstlisting}[style=styleCXX]
template<>
class Outer<bool>::Inner<wchar_t> {
	public:
	enum { count = 2 };
};
\end{lstlisting}
































