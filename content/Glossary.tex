
这个术语表是本书中使用的技术术语汇总。参见[StroustrupGlossary]了解C++程序员使用的全面、通用的术语表。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{抽象类(abstract class)}

不可能创建具体对象(实例)的类。抽象类可以用于在单一类型中收集不同类的公共属性，或者定义多态接口。因为抽象类可作为基类，所以缩写ABC有时用来表示抽象基类。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{ADL}

参数相关查找的缩写。ADL是一个进程，在命名空间和类中查找函数(或操作符)的名称，这些命名空间和类以某种方式与出现该函数(或操作符名称)的函数调用的参数相关联。由于历史原因，有时称为扩展Koenig查找，或是Koenig查找(后者也用于仅应用于操作符的ADL)。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{别名模板(alias template)}  

表示一组类型别名的构造，指定了一个模式，通过用特定的实体替换模板参数，可以从该模式生成实际的类型别名。别名模板可以是类成员。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{尖括号黑客(angle bracket hack)}

一种C++特性，要求编译器接受两个连续的右尖括号字符作为两个结束尖括号。例如，尖括号黑客会使vector<list<int>{}>与vector<list<int>{}>以相同地方式处理。其称为(词法)黑客，因为它不适合C++的正式规范(尤其是语法)，也不适合典型编译器的架构。另一个类似的黑客处理形成临时有向图(见有向图)。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{尖括号(angle brackets)}

字符<和>用作分隔符，而不是用作小于和大于操作符。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{ANSI}

美国国家标准协会(American National Standard Institute)的首字母缩写，该协会是一家私人非营利组织，负责协调各种标准规范的制定工作。看到INCITS。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{参数(argument)}

替代编程实体的参数的值(广义上)。例如，在函数abs(-3)调用中，参数是-3。一些编程社区中，参数称为实际参数(而声明参数称为形式参数)。参见模板参数。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{参数依赖查询(argument-dependent lookup)}

参见ADL。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{类(class)}
 
对一类对象的描述,类为该类型的对象定义了一组特征。这包括数据(属性、数据成员)以及操作(方法、成员函数)。C++中，类是具有成员(也可以是函数)的结构，并且受到访问限制。它们使用关键字class或struct声明。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{类模板(class template)}

一个表示类集的构造。其指定了一个模式，通过用特定的类型替换模板参数，可以从该模式生成实际的类。类模板有时称为参数化类。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{类类型(class type)}

用class、struct或union声明的C++类型。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{集合类(collection class)}

A class that is used to manage a group of objects. In C++, collection classes are also called containers.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{编译器(compiler)}

A program or library component that translates the source code in a translation unit into object code (machine code with symbolic annotations that allow a linker to resolve references across translation units).

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{完整的类型(complete type)}

Any type that is not incomplete: a defined class, an array of complete elements and known size, an enumeration type with defined underlying type, and any fundamental data type except void (optionally with const and/or volatile).

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{概念(concept)}

A named set of constraints that can be applied to one or more template parameters. See Appendix E.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{常量表达式(constant-expression)}

An expression whose value can be computed at compile time by the compiler. We sometimes call this a true constant to avoid confusion with constant expression (without hyphen). The latter includes expressions that are constant but cannot always be computed at compile time by the compiler.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{常量成员函数(const member function)}

A member function that can be called for constant and temporary objects because it does not normally modify members of the *this object.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{容器(container)}

See collection class.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{转换函数(conversion function)}

A special member function that defines how an object can implicitly (or explicitly) be converted to an object of another type. It is declared using the form operator type().

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{转换操作符(conversion operator)}

A synonym for conversion function. The latter is the standard term, but the former is also commonly
used.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{CPP文件(CPP file)}

A file in which definitions of variables and noninline functions are located. Most of the executable  (as opposed to declarative) code of a program is normally placed in CPP files. They are named CPP files because they are usually named with the suffix .cpp. But for historical reasons the suffix also might be .C, .c, .cc, or .cxx. See also header file and translation unit.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{奇异递归模板模式(CRTP)}

An acronym for curiously recurring template pattern. This refers to a code pattern where a class X derives from a base class that has X as a template argument.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{奇异递归模板模式(curiously recurring template pattern)}

See CRTP.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{衰变(decay)}

The implicit conversion of an array or a function to a pointer. For example, the string literal "Hello" has type char const[6], but in many C++ contexts, it is implicitly converted to a pointer of type char const* (which points to the first character of the string).

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{声明(declaration)}

A C++ construct that introduces or reintroduces a name into a C++ scope. See also definition.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{推导(deduction)}

The process that implicitly determines template arguments from the context in which templates are used. The complete term is template argument deduction.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{定义(definition)}

A declaration that makes the details of the declared entity known or, in the case of variables, that forces storage space to be reserved for the declared entity. For class types and function definitions, this amounts to declarations that include a brace-enclosed body. For external variable declarations, this means either a declaration with no extern keyword or a declaration with an initializer.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{相关基类(dependent base class)}

A base class that depends on a template parameter. Special care must be taken to access members of dependent base classes. See also two-phase lookup.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{相关名称(dependent name）}

A name the meaning of which depends on a template parameter. For example, A<T>::x is a dependent name when A or T is a template parameter. The name of a function in a function call is also dependent if any of the arguments in the call has a type that depends on a template parameter. For example, f in f((T*)0) is dependent if T is a template parameter. The name of a template parameter is not considered dependent, however. See also two-phase lookup.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{有向图(digraph)}

A combination of two consecutive characters that are equivalent to another single character in C++ code. The purpose of digraphs is to allow the input of C++ source code with keyboards that lack certain characters. Although it is used relatively rarely, the digraph <: is sometimes accidentally formed when a left angle bracket is followed by a scope resolution operator (::) without the required intervening whitespace. C++11 introduced a lexical hack to disable digraph interpretation under those circumstances.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{空基类优化(EBCO)}

An acronym for empty base class optimization. An optimization performed by most modern compilers whereby an “empty” base class subobject does not occupy any storage.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{空基类优化(empty base class optimization)}

See EBCO.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{显式实例化指令(explicit instantiation directive)}

A C++ construct whose sole purpose is to create a point of instantiation (POI).

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{显式特化(explicit specialization)}

A construct that declares or defines an alternative definition for a substituted template. The original (generic) template is called the primary template. If the alternative definition still depends on one or more template parameters, it is called a partial specialization. Otherwise, it is a full specialization.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{表达式模板(expression template)}

A class template used to represent a part of an expression. The template itself represents a particular kind of operation. The template parameters stand for the kinds of operands to which the operation applies.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{转发引用(forwarding reference)}

One of two terms for rvalue references of the form T\&\& where T is a deducible template parameter. Special rules that differ from ordinary rvalue references apply (see Section 6.1 on page 91). The term was introduced by C++17 as replacement for universal reference, because the primary use of such a reference is to forward objects. However, note that it does not automatically forward. That is, the term does not describe what it is but for what it is typically used for.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{友元名称注入(friend name injection)}

The process that makes a function name visible when its only declaration is a friend declaration.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{全特化(full specialization)}

See explicit specialization.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{函数对象(function object)}

An object that can be called using function call syntax. In C++, these are pointers to functions, classes with an overloaded operator() (see functor), and classes with a conversion function yielding a pointer to function or reference to function.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{函数模板(function template)}

A construct that represents a family of functions. It specifies a pattern from which actual functions can be generated by substituting the template parameters by specific entities. Note that a function template is a template and not a function. Function templates are sometimes called parameterized functions.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{函子/仿函数(functor)}

An object of a class type with an overloaded operator(), which can be called using function call syntax. This includes the closure type of a lambda expression.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{glvalue}

A category of expressions that produces a location for a stored value (generalized localizable value). A glvalue can be an lvalue or an xvalue. See value category and Section B.2 on page 674.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{头文件(header file)}

A file meant to become part of a translation unit through a \#include directive. Such files often contain declarations of variables and functions that are referred to from more than one translation unit, as well as definitions of types, inline functions, templates, constants, and macros. They are usually named with a suffix like .hpp, .h, .H, .hh, or .hxx. They are also called include files. See also CPP file and translation unit.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{国际信息技术标准委员会(INCITS)}

An acronym for InterNational Committee for Information Technology Standards, which is a U.S. standards development organization (formerly known a X3) accredited by ANSI. A subcommittee called J16 is a driving force behind the standardization of C++. It cooperates closely with the International Organization for Standardization (ISO).

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{包含文件(include file)}

See header file.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{不完整类型(incomplete type)}

A class that is declared but not defined, an array of incomplete element type or of unknown size, an enumeration type without the underlying type defined, or void (optionally with const and/or volatile).

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{间接调用(indirect call)}

A function call for which the called function is not known until the call actually occurs (at run time).

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{初始化式(initializer)}

A construct that specifies how to initialize an object. For example, the initializers are = 1.0 and (0.0, 1.0) in
\begin{lstlisting}[style=styleCXX]
std::complex<float> z1 = 1.0, z2(0.0, 1.0);
\end{lstlisting}

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{初始化列表(initializer list)}

A comma-separated list of expressions enclosed in braces used to initialize objects and references. Initializer lists are commonly used to initialize variables but also, for example, to initialize members and base classes in constructor definitions. This initialization may happen directly or via an intermediate std::initializer\_list object.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{类名称注入(injected class name)}

The name of a class as visible in its own definition scope. For class templates, the name of the template is treated within the scope of the template as a class name if the name is not followed by a template argument list.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{实例(instance)}

The term instance has two meanings in C++ programming: The meaning that is taken from the object-oriented terminology is an instance of a class: an object that is the realization of a class. For example, in C++, std::cout is an instance of the class std::ostream. The other meaning (and the one that is almost always intended in this book) is a template instance: a class, a function, or a member function obtained by substituting all the template parameters by specific values. In this sense, an instance is also called a specialization, although the latter term is often mistaken for explicit specialization.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{实例化(instantiation)}

The replacement of the template parameters in a template definition to create a concrete entity (function, class, variable, or alias). If only the declaration of a template but not its definition is substituted, the term partial template instantiation is sometimes used. See also substitution. The alternative sense of creating an instance (object) of a class is not used in this book (see instance).

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{国际标准化组织(ISO)}

Worldwide acronym for International Organization for Standardization. An ISO workgroup called WG21 is a driving force behind the efforts to standardize and develop C++.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{迭代器(iterator)}

An object that knows how to traverse a sequence of elements. Often, these elements belong to a collection (see collection class).

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{可链接的对象(linkable entity)}

Any of the following: a function or member function, a global variable or a static data member, including any such things generated from a template, as visible to the linker.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{连接器(linker)}

A program or operating system service that links together compiled translation units and resolves references to linkable entities across those translation units.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{左值(lvalue)}

A category of expressions that produces a location for a stored value that is not assumed to be movable (i.e., glvalues that are no xvalues). Typical examples are expressions denoting named objects (variables or members) and string literals. See value category and Section B.1 on page 673.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{成员类模板(member class template)}

A construct that represents a family of member classes. It is a class template declared inside another class or class template definition. It has its own set of template parameters (unlike a member class of a class template).

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{成员函数模板(member function template)}

A construct that represents a family of member functions. It has its own set of template parameters (unlike a member function of a class template). It is very similar to a function template, but when all the template parameters are substituted, the result is a member function (instead of an ordinary function). Member function templates cannot be virtual.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{成员模板(member template)}

A member class template, member function template, or static data member template.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{现代C++(Modern C++)}

The phrase used in this book to refer to the language as standardized in C++11 or later (i.e., C++11, C++14, or C++17).

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{不相关名称(nondependent name)}

A name that is not dependent on a template parameter. See dependent name and two-phase lookup.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{单一定义规则(ODR)}

An acronym for one-definition rule. This rule places some restrictions on the definitions that appear in a C++ program. See Section 10.4 on page 154 and Appendix A for details.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{单一定义规则(one-definition rule)}

See ODR.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{重载解析(overload resolution)}

The process that selects which function to call when several candidates (usually all having the same name) exist. See also Appendix C.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{参数(parameter)}

A placeholder entity that is meant to be substituted with an actual “value” (an argument) at some point. For macro parameters and template parameters, the substitution occurs at compile time. For function call parameters, it happens at run time. In some programming communities, parameters are called formal parameters (whereas arguments are called actual parameters). See also argument and template argument.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{参数化类(parameterized class)}

A class template or a class nested in a class template. Both are parameterized because they do not correspond to a unique class until the template arguments have been specified.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{参数化函数(parameterized function)}

A function or member function template or a member function of a class template. All are parameterized because they do not correspond to a unique function (or member function) until the template arguments have been specified.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{偏特化(partial specialization)}

A construct that declares or defines an alternative definition for certain substitutions of a template. The original (generic) template is called the primary template. The alternative definition still depends on template parameters. Currently, this construct exists only for class templates. See also explicit specialization.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{普通的旧数据(POD)}

An acronym for “plain old data (type).” POD types are types that can be defined without certain C++ features (like virtual member functions, access keywords, and so forth). For example, every ordinary C struct is a POD.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{实例化点(POI)}

An acronym for point of instantiation. A POI is a location in the source code where a template (or a member of a template) is conceptually expanded by substituting template parameters with template arguments. In practice, this expansion does not need to occur at every POI. See also explicit instantiation directive.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{实例化点(point of instantiation)}

See POI.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{策略类(policy class)}

A class or class template the members of which describe configurable behavior for a generic component. Policies are normally passed as template arguments. For example, a sorting template may have an ordering policy. Policy classes are also called policy templates or just policies. See also traits template.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{多态性(polymorphism)}

The ability of an operation (which is identified by its name) to apply to objects of different kinds. In C++, the traditional object-oriented concept of polymorphism (also called run-time or dynamic polymorphism) is achieved through virtual functions that are overridden in derived classes. In addition, C++ templates enable static polymorphism.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{预编译头文件(precompiled header)}

A processed form of source code that can quickly be loaded by the compiler. The source code underlying a precompiled header must be the first part of a translation unit (i.e., it cannot start somewhere in the middle of a translation unit). Often, a precompiled header corresponds to a number of header files. Using precompiled headers can substantially reduce the time needed to build a large application written in C++.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{主模板(primary template)}

A template that is not a partial specialization.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{prvalue}

A category of expressions that perform initializations. Prvalues can be assumed to designate pure mathematical value such as 1 or true and temporaries (especially values returned by value). Any rvalue before C++11 is a prvalue in C++11. See value category and Section B.2 on page 674.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{限定名(qualified name)}

A name containing a scope qualifier (::).

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{引用计数(reference counting)}

A resource management strategy that keeps count of how many entities are referring to a particular resource. When the count drops to zero, the resource can be disposed of.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{右值(rvalue)}

A category of expressions that are not lvalues. An rvalue can be a prvalue (such as a temporary) or an xvalue (e.g., an lvalue marked with std::move()). What was called a rvalue before C++11 is called a prvalue in C++11. See value category and Section B.2 on page 674.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{替换失败不为过(SFINAE)}

An acronym for substitution failure is not an error. A mechanism that silently discards templates instead of triggering compilation errors when attempting to substitute template arguments in invalid ways. Other templates in an overload set then get a chance to be selected if their substitution is successful.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{源文件(source file)}

A header file or a CPP file.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{特化(specialization)}

The result of substituting template parameters with actual values. A specialization may be created by an instantiation or by an explicit specialization. This term is sometimes mistakenly equated with explicit specialization. See also instance.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{静态数据成员模板(static data member template)}

A variable template that is a member of a class or class template.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{替换(substitution)}

The process of replacing template parameters in templated entities by actual types, values, or templates. The extent of the substitution depends on the context. During overload resolution, for example, only the minimum amount of substitution to establish the type of a candidate function is performed, and if that substitution leads to invalid constructs, the SFINAE rules apply. See also instantiation.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{模板(template)}

A construct that represents a family of types, functions, member functions, or variables. It specifies a pattern from which actual types, functions, member functions, or variables can be generated by substituting the template parameters by specific entities. In this book, the term does not include functions, classes, static data members, and type aliases that are parameterized only by virtue of being members of a class template. See alias template, variable template, class template, parameterized class, function template, and parameterized function.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{模板参数(template argument)}

The “value” substituted for a template parameter. This value is usually a type, although certain constant values and templates can be valid template arguments too. See also argument.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{模板参数推导(template argument deduction)}

See deduction.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{模板标识(template-id)}

The combination of a template name followed by template arguments specified between angle brackets (e.g., std::list<int>).

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{模板参数(template parameter)}

A generic placeholder in a template. The most common kind of template parameter are type parameters, which represent types. Nontype parameters represent constant values of a certain type, and template template parameters represent type templates. See also parameter.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{模板化实体(templated entity)}

A template or an entity defined or created in a template. The latter includes things like an ordinary member function of a class template or the closure type of a lambda expression appearing in a template.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{特征模板(traits template)}

A class template with members that describe characteristics (traits) of the template arguments. Usually the purpose of traits templates is to avoid an excessive number of template parameters. See also policy class.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{翻译单元(translation unit)}

A CPP file with all the header files and standard library headers it includes using \#include directives, minus the program text that is excluded by conditional compilation directives such as \#if. For simplicity, it can also be thought of as the result of preprocessing a CPP file. See CPP file and header file.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{真常量(true constant)}

An expression whose value can be computed at compile time by the compiler. See constant-expression.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{元组(tuple)}

A generalization of the C struct concept such that members can be accessed by number.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{两阶段查找(two-phase lookup)}

The name lookup mechanism used for names in templates. The two phases are (1) the processing of the template definition, and (2) the instantiation of the template for specific template arguments. Nondependent names are looked up only in the first phase, nondependent base classes are not considered during that phase. Dependent names with a scope qualifier (::) are looked up only in the second phase. Dependent names without a scope qualifier may be looked up in both phases, but in the second phase, only argument-dependent lookup is performed.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{类型别名(type alias)}

An alternative name for a type, introduced using a typedef declaration, an alias declaration, or the instantiation of an alias template.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{类型模板(type template)}

A class template, member class template, or alias template.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{通用引用(universal reference)}

One of two terms for rvalue references of the form T\&\& where T is a deducible template parameter. Special rules that differ from ordinary rvalue references apply (see Section 6.1 on page 91). The term was coined by Scott Meyers as a common term for both lvalue reference and rvalue reference. Because “universal” was, well, too universal, the C++17 standard introduced the term forwarding reference instead.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{用户定义的转换(user-defined conversion)}

A type conversion defined by the programmer. It can be a constructor that can be called with one argument or a conversion function. Unless the constructor or conversion function is declared with the keyword explicit, the type conversion can occur implicitly.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{值类别(value category)}

A classification of expressions. The traditional value categories lvalues and rvalues were inherited from C. C++11 introduced alternative categories: glvalues (generalized lvalues), whose evaluation identifies stored objects, and prvalues (pure rvalues), whose evaluation initialize objects. Additional categories subdivide glvalues into lvalues (localizable values) and xvalues (eXpiring values). In addition, in C++11 rvalues serve as a general category for both xvalues and prvalues (before C++11, rvalues were what prvalues are in C++11). See Appendix B for details.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{变量模板(variable template)}

A construct that represents a family of variables or static data members. It specifies a pattern from which actual variables and static data members can be generated by substituting the template parameters by specific entities.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{空白(whitespace)}

In C++, this is the space that delimits the tokens (identifiers, literals, symbols, and so on) in source code. Besides the traditional blank space, new line, and horizontal tabulation characters, this also includes comments. Other whitespace characters (e.g., the page feed control character) are sometimes also valid whitespace.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{xvalue}

A category of expressions that produce a location for a stored object that can be assumed to be no longer needed. A typical example is an lvalue marked with std::move(). See value category and Section B.2 on page 674.




















