
This glossary is a compilation of the most important technical terms that are used in this book. See [StroustrupGlossary] for a comprehensive, general glossary of terms used by C++ programmers.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{abstract class}

A class for which the creation of concrete objects (instances) is impossible. Abstract classes can be used to collect common properties of different classes in a single type or to define a polymorphic interface. Because abstract classes are used as base classes, the acronym ABC is sometimes used for abstract base class.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{ADL}

An acronym for argument-dependent lookup. ADL is a process that looks for a name of a function (or operator) in namespaces and classes that are in some way associated with the arguments of the function call in which that function (or operator name) appears. For historical reasons, it is sometimes called extended Koenig lookup or just Koenig lookup (the latter is also used for ADL applied to operators only).

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{alias template}  

A construct that represents a family of type aliases. It specifies a pattern from which actual type aliases can be generated by substituting the template parameters by specific entities. An alias template can be a class member.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{angle bracket hack}

A C++ feature that requires a compiler to accept two consecutive > characters as two closing angle brackets. For example, the angle bracket hack causes vector<list<int>> to be treated identically to vector<list<int> >. It’s called a (lexical) hack because it doesn’t fit well in the C++ formal specification (the grammar, in particular) nor in the general architecture of typical compilers. Another similar hack deals with accidental digraph formation (see digraph).

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{angle brackets}

The characters < and > when they are used as delimiters rather than as less-than and greater-than operators.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{ANSI}

An acronym for American National Standard Institute, a private, nonprofit organization that coordinates efforts to produce standard specifications of all kinds. See INCITS. 

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{argument}

A value (in a broad sense) that substitutes a parameter of a programmatic entity. For example, in a function call abs(-3), the argument is -3. In some programming communities, arguments are called actual parameters (whereas parameters are called formal parameters). See also template argument.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{argument-dependent lookup}

See ADL.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{class}
 
The description of a category of objects. The class defines a set of characteristics for any object of that type. These include its data (attributes, data members) as well as its operations (methods, member functions). In C++, classes are structures with members that can also be functions and are subject to access limitations. They are declared using the keywords class or struct.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{class template}

A construct that represents a family of classes. It specifies a pattern from which actual classes can be generated by substituting the template parameters by specific entities. Class templates are sometimes called parameterized classes.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{class type}

A C++ type declared with class, struct, or union.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{collection class}

A class that is used to manage a group of objects. In C++, collection classes are also called containers.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{compiler}

A program or library component that translates the source code in a translation unit into object code (machine code with symbolic annotations that allow a linker to resolve references across translation units).

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{complete type}

Any type that is not incomplete: a defined class, an array of complete elements and known size, an enumeration type with defined underlying type, and any fundamental data type except void (optionally with const and/or volatile).

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{concept}

A named set of constraints that can be applied to one or more template parameters. See Appendix E.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{constant-expression}

An expression whose value can be computed at compile time by the compiler. We sometimes call this a true constant to avoid confusion with constant expression (without hyphen). The latter includes expressions that are constant but cannot always be computed at compile time by the compiler.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{const member function}

A member function that can be called for constant and temporary objects because it does not normally modify members of the *this object.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{container}

See collection class.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{conversion function}

A special member function that defines how an object can implicitly (or explicitly) be converted to an object of another type. It is declared using the form operator type().

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{conversion operator}

A synonym for conversion function. The latter is the standard term, but the former is also commonly
used.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{CPP file}

A file in which definitions of variables and noninline functions are located. Most of the executable  (as opposed to declarative) code of a program is normally placed in CPP files. They are named CPP files because they are usually named with the suffix .cpp. But for historical reasons the suffix also might be .C, .c, .cc, or .cxx. See also header file and translation unit.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{CRTP}

An acronym for curiously recurring template pattern. This refers to a code pattern where a class X derives from a base class that has X as a template argument.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{curiously recurring template pattern}

See CRTP.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{decay}

The implicit conversion of an array or a function to a pointer. For example, the string literal "Hello" has type char const[6], but in many C++ contexts, it is implicitly converted to a pointer of type char const* (which points to the first character of the string).

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{declaration}

A C++ construct that introduces or reintroduces a name into a C++ scope. See also definition.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{deduction}

The process that implicitly determines template arguments from the context in which templates are used. The complete term is template argument deduction.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{definition}

A declaration that makes the details of the declared entity known or, in the case of variables, that forces storage space to be reserved for the declared entity. For class types and function definitions, this amounts to declarations that include a brace-enclosed body. For external variable declarations, this means either a declaration with no extern keyword or a declaration with an initializer.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{dependent base class}

A base class that depends on a template parameter. Special care must be taken to access members of dependent base classes. See also two-phase lookup.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{dependent name}

A name the meaning of which depends on a template parameter. For example, A<T>::x is a dependent name when A or T is a template parameter. The name of a function in a function call is also dependent if any of the arguments in the call has a type that depends on a template parameter. For example, f in f((T*)0) is dependent if T is a template parameter. The name of a template parameter is not considered dependent, however. See also two-phase lookup.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{digraph}

A combination of two consecutive characters that are equivalent to another single character in C++ code. The purpose of digraphs is to allow the input of C++ source code with keyboards that lack certain characters. Although it is used relatively rarely, the digraph <: is sometimes accidentally formed when a left angle bracket is followed by a scope resolution operator (::) without the required intervening whitespace. C++11 introduced a lexical hack to disable digraph interpretation under those circumstances.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{EBCO}

An acronym for empty base class optimization. An optimization performed by most modern compilers whereby an “empty” base class subobject does not occupy any storage.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{empty base class optimization}

See EBCO.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{explicit instantiation directive}

A C++ construct whose sole purpose is to create a point of instantiation (POI).

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{explicit specialization}

A construct that declares or defines an alternative definition for a substituted template. The original (generic) template is called the primary template. If the alternative definition still depends on one or more template parameters, it is called a partial specialization. Otherwise, it is a full specialization.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{expression template}

A class template used to represent a part of an expression. The template itself represents a particular kind of operation. The template parameters stand for the kinds of operands to which the operation applies.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{forwarding reference}

One of two terms for rvalue references of the form T\&\& where T is a deducible template parameter. Special rules that differ from ordinary rvalue references apply (see Section 6.1 on page 91). The term was introduced by C++17 as replacement for universal reference, because the primary use of such a reference is to forward objects. However, note that it does not automatically forward. That is, the term does not describe what it is but for what it is typically used for.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{friend name injection}

The process that makes a function name visible when its only declaration is a friend declaration.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{full specialization}

See explicit specialization.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{function object}

An object that can be called using function call syntax. In C++, these are pointers to functions, classes with an overloaded operator() (see functor), and classes with a conversion function yielding a pointer to function or reference to function.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{function template}

A construct that represents a family of functions. It specifies a pattern from which actual functions can be generated by substituting the template parameters by specific entities. Note that a function template is a template and not a function. Function templates are sometimes called parameterized functions.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{functor}

An object of a class type with an overloaded operator(), which can be called using function call syntax. This includes the closure type of a lambda expression.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{glvalue}

A category of expressions that produces a location for a stored value (generalized localizable value). A glvalue can be an lvalue or an xvalue. See value category and Section B.2 on page 674.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{header file}

A file meant to become part of a translation unit through a \#include directive. Such files often contain declarations of variables and functions that are referred to from more than one translation unit, as well as definitions of types, inline functions, templates, constants, and macros. They are usually named with a suffix like .hpp, .h, .H, .hh, or .hxx. They are also called include files. See also CPP file and translation unit.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{INCITS}

An acronym for InterNational Committee for Information Technology Standards, which is a U.S. standards development organization (formerly known a X3) accredited by ANSI. A subcommittee called J16 is a driving force behind the standardization of C++. It cooperates closely with the International Organization for Standardization (ISO).

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{include file}

See header file.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{incomplete type}

A class that is declared but not defined, an array of incomplete element type or of unknown size, an enumeration type without the underlying type defined, or void (optionally with const and/or volatile).

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{indirect call}

A function call for which the called function is not known until the call actually occurs (at run time).

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{initializer}

A construct that specifies how to initialize an object. For example, in
\begin{lstlisting}[style=styleCXX]
std::complex<float> z1 = 1.0, z2(0.0, 1.0);
\end{lstlisting}
the initializers are = 1.0 and (0.0, 1.0).

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{initializer list}

A comma-separated list of expressions enclosed in braces used to initialize objects and references. Initializer lists are commonly used to initialize variables but also, for example, to initialize members and base classes in constructor definitions. This initialization may happen directly or via an intermediate std::initializer\_list object.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{injected class name}

The name of a class as visible in its own definition scope. For class templates, the name of the template is treated within the scope of the template as a class name if the name is not followed by a template argument list.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{instance}

The term instance has two meanings in C++ programming: The meaning that is taken from the object-oriented terminology is an instance of a class: an object that is the realization of a class. For example, in C++, std::cout is an instance of the class std::ostream. The other meaning (and the one that is almost always intended in this book) is a template instance: a class, a function, or a member function obtained by substituting all the template parameters by specific values. In this sense, an instance is also called a specialization, although the latter term is often mistaken for explicit specialization.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{instantiation}

The replacement of the template parameters in a template definition to create a concrete entity (function, class, variable, or alias). If only the declaration of a template but not its definition is substituted, the term partial template instantiation is sometimes used. See also substitution. The alternative sense of creating an instance (object) of a class is not used in this book (see instance).

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{ISO}

Worldwide acronym for International Organization for Standardization. An ISO workgroup called WG21 is a driving force behind the efforts to standardize and develop C++.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{iterator}

An object that knows how to traverse a sequence of elements. Often, these elements belong to a collection (see collection class).

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{linkable entity}

Any of the following: a function or member function, a global variable or a static data member, including any such things generated from a template, as visible to the linker.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{linker}

A program or operating system service that links together compiled translation units and resolves references to linkable entities across those translation units.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{lvalue}

A category of expressions that produces a location for a stored value that is not assumed to be movable (i.e., glvalues that are no xvalues). Typical examples are expressions denoting named objects (variables or members) and string literals. See value category and Section B.1 on page 673.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{member class template}

A construct that represents a family of member classes. It is a class template declared inside another class or class template definition. It has its own set of template parameters (unlike a member class of a class template).

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{member function template}

A construct that represents a family of member functions. It has its own set of template parameters (unlike a member function of a class template). It is very similar to a function template, but when all the template parameters are substituted, the result is a member function (instead of an ordinary function). Member function templates cannot be virtual.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{member template}

A member class template, member function template, or static data member template.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{Modern C++}

The phrase used in this book to refer to the language as standardized in C++11 or later (i.e., C++11, C++14, or C++17).

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{nondependent name}

A name that is not dependent on a template parameter. See dependent name and two-phase lookup.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{ODR}

An acronym for one-definition rule. This rule places some restrictions on the definitions that appear in a C++ program. See Section 10.4 on page 154 and Appendix A for details.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{one-definition rule}

See ODR.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{overload resolution}

The process that selects which function to call when several candidates (usually all having the same name) exist. See also Appendix C.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{parameter}

A placeholder entity that is meant to be substituted with an actual “value” (an argument) at some point. For macro parameters and template parameters, the substitution occurs at compile time. For function call parameters, it happens at run time. In some programming communities, parameters are called formal parameters (whereas arguments are called actual parameters). See also argument and template argument.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{parameterized class}

A class template or a class nested in a class template. Both are parameterized because they do not correspond to a unique class until the template arguments have been specified.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{parameterized function}

A function or member function template or a member function of a class template. All are parameterized because they do not correspond to a unique function (or member function) until the template arguments have been specified.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{partial specialization}

A construct that declares or defines an alternative definition for certain substitutions of a template. The original (generic) template is called the primary template. The alternative definition still depends on template parameters. Currently, this construct exists only for class templates. See also explicit specialization.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{POD}

An acronym for “plain old data (type).” POD types are types that can be defined without certain C++ features (like virtual member functions, access keywords, and so forth). For example, every ordinary C struct is a POD.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{POI}

An acronym for point of instantiation. A POI is a location in the source code where a template (or a member of a template) is conceptually expanded by substituting template parameters with template arguments. In practice, this expansion does not need to occur at every POI. See also explicit instantiation directive.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{point of instantiation}

See POI.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{policy class}

A class or class template the members of which describe configurable behavior for a generic component. Policies are normally passed as template arguments. For example, a sorting template may have an ordering policy. Policy classes are also called policy templates or just policies. See also traits template.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{polymorphism}

The ability of an operation (which is identified by its name) to apply to objects of different kinds. In C++, the traditional object-oriented concept of polymorphism (also called run-time or dynamic polymorphism) is achieved through virtual functions that are overridden in derived classes. In addition, C++ templates enable static polymorphism.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{precompiled header}

A processed form of source code that can quickly be loaded by the compiler. The source code underlying a precompiled header must be the first part of a translation unit (i.e., it cannot start somewhere in the middle of a translation unit). Often, a precompiled header corresponds to a number of header files. Using precompiled headers can substantially reduce the time needed to build a large application written in C++.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{primary template}

A template that is not a partial specialization.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{prvalue}

A category of expressions that perform initializations. Prvalues can be assumed to designate pure mathematical value such as 1 or true and temporaries (especially values returned by value). Any rvalue before C++11 is a prvalue in C++11. See value category and Section B.2 on page 674.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{qualified name}

A name containing a scope qualifier (::).

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{reference counting}

A resource management strategy that keeps count of how many entities are referring to a particular resource. When the count drops to zero, the resource can be disposed of.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{rvalue}

A category of expressions that are not lvalues. An rvalue can be a prvalue (such as a temporary) or an xvalue (e.g., an lvalue marked with std::move()). What was called a rvalue before C++11 is called a prvalue in C++11. See value category and Section B.2 on page 674.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{SFINAE}

An acronym for substitution failure is not an error. A mechanism that silently discards templates instead of triggering compilation errors when attempting to substitute template arguments in invalid ways. Other templates in an overload set then get a chance to be selected if their substitution is successful.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{source file}

A header file or a CPP file.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{specialization}

The result of substituting template parameters with actual values. A specialization may be created by an instantiation or by an explicit specialization. This term is sometimes mistakenly equated with explicit specialization. See also instance.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{static data member template}

A variable template that is a member of a class or class template.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{substitution}

The process of replacing template parameters in templated entities by actual types, values, or templates. The extent of the substitution depends on the context. During overload resolution, for example, only the minimum amount of substitution to establish the type of a candidate function is performed, and if that substitution leads to invalid constructs, the SFINAE rules apply. See also instantiation.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{template}

A construct that represents a family of types, functions, member functions, or variables. It specifies a pattern from which actual types, functions, member functions, or variables can be generated by substituting the template parameters by specific entities. In this book, the term does not include functions, classes, static data members, and type aliases that are parameterized only by virtue of being members of a class template. See alias template, variable template, class template, parameterized class, function template, and parameterized function.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{template argument}

The “value” substituted for a template parameter. This value is usually a type, although certain constant values and templates can be valid template arguments too. See also argument.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{template argument deduction}

See deduction.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{template-id}

The combination of a template name followed by template arguments specified between angle brackets (e.g., std::list<int>).

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{template parameter}

A generic placeholder in a template. The most common kind of template parameter are type parameters, which represent types. Nontype parameters represent constant values of a certain type, and template template parameters represent type templates. See also parameter.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{templated entity}

A template or an entity defined or created in a template. The latter includes things like an ordinary member function of a class template or the closure type of a lambda expression appearing in a template.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{traits template}

A class template with members that describe characteristics (traits) of the template arguments. Usually the purpose of traits templates is to avoid an excessive number of template parameters. See also policy class.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{translation unit}

A CPP file with all the header files and standard library headers it includes using \#include directives, minus the program text that is excluded by conditional compilation directives such as \#if. For simplicity, it can also be thought of as the result of preprocessing a CPP file. See CPP file and header file.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{true constant}

An expression whose value can be computed at compile time by the compiler. See constant-expression.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{tuple}

A generalization of the C struct concept such that members can be accessed by number.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{two-phase lookup}

The name lookup mechanism used for names in templates. The two phases are (1) the processing of the template definition, and (2) the instantiation of the template for specific template arguments. Nondependent names are looked up only in the first phase, nondependent base classes are not considered during that phase. Dependent names with a scope qualifier (::) are looked up only in the second phase. Dependent names without a scope qualifier may be looked up in both phases, but in the second phase, only argument-dependent lookup is performed.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{type alias}

An alternative name for a type, introduced using a typedef declaration, an alias declaration, or the instantiation of an alias template.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{type template}

A class template, member class template, or alias template.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{universal reference}

One of two terms for rvalue references of the form T\&\& where T is a deducible template parameter. Special rules that differ from ordinary rvalue references apply (see Section 6.1 on page 91). The term was coined by Scott Meyers as a common term for both lvalue reference and rvalue reference. Because “universal” was, well, too universal, the C++17 standard introduced the term forwarding reference instead.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{user-defined conversion}

A type conversion defined by the programmer. It can be a constructor that can be called with one argument or a conversion function. Unless the constructor or conversion function is declared with the keyword explicit, the type conversion can occur implicitly.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{value category}

A classification of expressions. The traditional value categories lvalues and rvalues were inherited from C. C++11 introduced alternative categories: glvalues (generalized lvalues), whose evaluation identifies stored objects, and prvalues (pure rvalues), whose evaluation initialize objects. Additional categories subdivide glvalues into lvalues (localizable values) and xvalues (eXpiring values). In addition, in C++11 rvalues serve as a general category for both xvalues and prvalues (before C++11, rvalues were what prvalues are in C++11). See Appendix B for details.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{variable template}

A construct that represents a family of variables or static data members. It specifies a pattern from which actual variables and static data members can be generated by substituting the template parameters by specific entities.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{whitespace}

In C++, this is the space that delimits the tokens (identifiers, literals, symbols, and so on) in source code. Besides the traditional blank space, new line, and horizontal tabulation characters, this also includes comments. Other whitespace characters (e.g., the page feed control character) are sometimes also valid whitespace.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{xvalue}

A category of expressions that produce a location for a stored object that can be assumed to be no longer needed. A typical example is an lvalue marked with std::move(). See value category and Section B.2 on page 674.




















