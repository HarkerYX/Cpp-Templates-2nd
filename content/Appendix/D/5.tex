

表D.7列出了所有剩余的类型特征，可以查询特殊属性或提供更复杂的类型转换。

\begin{table}[H]
	\begin{center}
	\begin{tabular}{l|l}
		\hline
		\textbf{特性}                                       & \textbf{作用}                                                   \\ \hline
		enable\_if\textless{}B,T=void \textgreater{}         & 当bool B为true时才返回类型T                              \\ \hline
		conditional\textless{}B,T,F \textgreater{}           & 若bool B为真，则返回类型T，否则返回类型F              \\ \hline
		common\_type\textless{}T1,... \textgreater{}         & 所有传递类型的通用类型                                   \\ \hline
		aligned\_storage\textless{}Len \textgreater{}        & 默认Len字节对齐的类型                          \\ \hline
		aligned\_storage\textless{}Len,Align \textgreater{}  & 根据size\_t Align的除数，对齐Len字节的类型 \\ \hline
		aligned\_union\textless{}Len,Types... \textgreater{} & Len字节对齐的Types…联合类型                 \\ \hline
	\end{tabular}
	\end{center}
\end{table}

\begin{center}
表D.7. 剩余类型特征
\end{center}

std::enable\_if<cond>::type

std::enable\_if<cond, T>::type

\begin{itemize}
\item
如果cond为true，则在其成员类型中返回void或T。否则，不定义成员类型。

\item
因为当cond为false时，没有定义类型成员，因此该特性可以通常给定的条件，禁用或使用SFINAE退出函数模板。

\item
请参阅第6.3节了解详细信息和第一个例子。有关使用参数包的另一个例子，请参阅第D.6节。

\item
有关std::enable\_if如何实现的详细信息，请参见第20.3节。
\end{itemize}

std::conditional<cond, T, F>::type

\begin{itemize}
\item
如果cond为真，则为T，否则为F。

\item
这是19.7.1节介绍的特征IfThenElseT的标准版本。

\item
与普通的C++ if-then-else语句不同，then和else分支的模板参数都是在选择之前进行求值的，因此两个分支都不包含错误的代码，或者程序可能是格式错误的。因此，可能需要添加一个间接级别，以避免then和else分支中的表达式在未使用该分支时进行计算。第19.7.1节演示了特征IfThenElseT的这个功能，其具有相同的行为。

\item
参见第11.5节中的示例。

\item
请参阅19.7.1节，了解std::conditional的实现。
\end{itemize}

std::common\_type<T...>::type

\begin{itemize}
\item
Yields the “common type” of the given types T1, T2, ..., Tn.

\item
The computation of a common type is a little more complex than we want to cover in this appendix. Roughly speaking, the common type of two types U and V is the type produced by the conditional operator ?: when its second and third operands are of those types U and V (with reference types used only to determine the value category of the two operands); there is no common type if that is invalid. decay\_t (see page 731) is applied to this result. This default computation may be overridden by user specialization of std::common\_type<U, V> (in the C++ standard library, partial specialization exists for durations and time points).

\item
If no type is given or no common type exists, there is no type member defined, so that using it is an error (which might SFINAE out a function template using it).

\item
If a single type is given, the result is the application of decay\_t to that type.

\item
For more than two types, common\_type recursively replaces the first two types T1 and T2 by their common type. If at any time that process fails, there is no common type.

\item
While processing the common type, the passed types are decays, so that the trait always yields a decayed type (see Section D.4 on page 731).

\item
See Section 1.3.3 on page 12 for a discussion and example of the application of this trait.

\item
The core of the primary template of this trait is usually implemented by something like the following (here using only two parameters):
\begin{lstlisting}[style=styleCXX]
template<typename T1, typename T2>
struct common_type<T1,T2> {
	using type = std::decay_t<decltype(true ? std::declval<T1>()
	: std::declval<T2>())>;
};
\end{lstlisting}
\end{itemize}

std::aligned\_union < MIN\_SZ, T... >::type

\begin{itemize}
\item
Yields a plain old datatype (POD) usable as uninitialized storage that has a size of at least MIN\_SZ and is suitable to hold any of the given types T1, T2, ..., Tn.

\item
In addition, it yields a static member alignment\_value whose value is the strictest alignment of all the given types, which for the result type is equivalent to

\begin{itemize}
\item[-]
std::alignment\_of\_v<type>::value (see Section D.3.1 on page 715)

\item[-]
alignof(type)
\end{itemize}

\item
Requires that at least one type is provided.

\item
For example:
\begin{lstlisting}[style=styleCXX]
using POD_T = std::aligned_union_t<0, char,
								std::pair<std::string,std::string>>;
std::cout << sizeof(POD_T) << ’\n’;
std::cout << std::aligned_union<0, char,
								std::pair<std::string,std::string>
								>::alignment_value;
		<< ’\n’;
\end{lstlisting}

Note the use of aligned\_union instead of aligned\_union\_t to get the value for the alignment instead of the type.
\end{itemize}

std::aligned\_storage < MAX\_TYPE\_SZ >::type

std::aligned\_storage < MAX\_TYPE\_SZ, DEF\_ALIGN >::type

\begin{itemize}
\item
Yields a plain old data type (POD) usable as uninitialized storage that has a size to hold all possible types with a size up to MAX\_TYPE\_SZ, taking the default alignment or the alignment passed as DEF\_ALIGN into account.

\item
Requires that MAX\_TYPE\_SZ is greater than zero and the platform has at least one type with the alignment value DEF\_ALIGN.

\item
For example:
\begin{lstlisting}[style=styleCXX]
using POD_T = std::aligned_storage_t<5>;
\end{lstlisting}
\end{itemize}













