
The next group of traits tests other properties of single types as well as certain operations (e.g., value swapping) that may apply to them.

\subsubsubsection{D.3.1\hspace{0.2cm}Other Type Properties}

std::is\_signed < T >::value

\begin{itemize}
\item 
Yields true if T is a signed arithmetic type (i.e., an arithmetic type  that includes negative value representations; this includes types like (signed) int, float).

\item 
For type bool, it yields false.

\item 
For type char, it is implementation defined whether it yields true or false.

\item 
For all nonarithmetic types (including enumeration types) is\_signed yields false.
\end{itemize}

std::is\_unsigned < T >::value

\begin{itemize}
\item 
Yields true if T is an unsigned arithmetic type (i.e., an arithmetic type that does not include negative value representations; this includes types like unsigned int and bool).

\item 
For type char, it is implementation defined whether it yields true or false.

\item 
For type char, it is implementation defined whether it yields true or false.

\item 
For all nonarithmetic types (including enumeration types) is\_unsigned yields false.
\end{itemize}

std::is\_const < T >::value

\begin{itemize}
\item 
Yields true if the type is const-qualified.

\item 
Note that a const pointer has a const-qualified type, whereas a non-const pointer or a reference to a const type is not const-qualified. For example:
\begin{lstlisting}[style=styleCXX]
is_const<int* const>::value // true
is_const<int const*>::value // false
is_const<int const&>::value // false
\end{lstlisting}

\item 
The language defines arrays to be const-qualified if the element type is const-qualified.

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm}This was clarified by the resolution of core issue 1059 after C++11 was published.
\end{tcolorbox}

For example:
\begin{lstlisting}[style=styleCXX]
is_const<int[3]>::value // false
is_const<int const[3]>::value // true
is_const<int[]>::value // false
is_const<int const[]>::value // true
\end{lstlisting}

\end{itemize}

\begin{table}[H]
	\begin{tabular}{|l|l|}
		\hline
		\textbf{Trait}                                                  & \textbf{Effect}                                                                                                            \\ \hline
		is\_signed\textless{}T \textgreater{}                           & Signed arithmetic type                                                                                                     \\ \hline
		is\_unsigned\textless{}T \textgreater{}                         & Unsigned arithmetic type                                                                                                   \\ \hline
		is\_const\textless{}T \textgreater{}                            & const-qualified                                                                                                            \\ \hline
		is\_volatile\textless{}T \textgreater{}                         & volatile-qualified                                                                                                         \\ \hline
		is\_aggregate\textless{}T \textgreater{}                        & Aggregate type (since C++17)                                                                                               \\ \hline
		is\_trivial\textless{}T \textgreater{}                          & Scalar, trivial class, or arrays of these types                                                                            \\ \hline
		is\_trivially\_copyable\textless{}T \textgreater{}              & Scalar, trivially copyable class, or arrays of these types                                                                 \\ \hline
		is\_standard\_layout\textless{}T \textgreater{}                 & Scalar, standard layout class, or arrays of these types                                                                    \\ \hline
		is\_pod\textless{}T \textgreater{}                              & \begin{tabular}[c]{@{}l@{}}Plain old data type (type where memcpy() works to\\ copy objects)\end{tabular}                  \\ \hline
		is\_literal\_type\textless{}T \textgreater{}                    & \begin{tabular}[c]{@{}l@{}}Scalar, reference, class, or arrays of these types\\ (deprecated since C++17)\end{tabular}      \\ \hline
		is\_empty\textless{}T \textgreater{}                            & \begin{tabular}[c]{@{}l@{}}Class with no members, virtual member functions, or\\ virtual base classes\end{tabular}         \\ \hline
		is\_polymorphic\textless{}T \textgreater{}                      & Class with a (derived) virtual member function                                                                             \\ \hline
		is\_abstract\textless{}T \textgreater{}                         & Abstract class (at least one pure virtual function)                                                                        \\ \hline
		is\_final\textless{}T \textgreater{}                            & \begin{tabular}[c]{@{}l@{}}Final class (a class not allowed to derive from, since\\ C++14)\end{tabular}                    \\ \hline
		has\_virtual\_destructor\textless{}T \textgreater{}             & Class with virtual destructor                                                                                              \\ \hline
		has\_unique\_object\_representations\textless{}T \textgreater{} & \begin{tabular}[c]{@{}l@{}}Any two object with same value have same representation \\ in memory (since C++17)\end{tabular} \\ \hline
		alignment\_of\textless{}T \textgreater{}                        & Equivalent to alignof(T)                                                                                                   \\ \hline
		rank\textless{}T \textgreater{}                                 & Number of dimensions of an array type (or 0)                                                                               \\ \hline
		extent\textless{}T,I=0 \textgreater{}                           & Extent of dimension I (or 0)                                                                                               \\ \hline
		underlying\_type\textless{}T \textgreater{}                     & Underlying type of an enumeration type                                                                                     \\ \hline
		is\_invocable\textless{}T,Args... \textgreater{}                & Can be used as callable for Args... (since C++17)                                                                          \\ \hline
		is\_nothrow\_invocable\textless{}T,Args... \textgreater{}       & \begin{tabular}[c]{@{}l@{}}Can be used as callable for Args... without throwing\\ (since C++17)\end{tabular}               \\ \hline
		is\_invocable\_r\textless{}RT,T,Args... \textgreater{}          & \begin{tabular}[c]{@{}l@{}}Can be used as callable for Args... returning RT (since\\ C++17)\end{tabular}                   \\ \hline
		is\_nothrow\_invocable\_r\textless{}RT,T,Args... \textgreater{} & \begin{tabular}[c]{@{}l@{}}Can be used as callable for Args... returning RT \\ without throwing (since C++17)\end{tabular} \\ \hline
		invoke\_result\textless{}T,Args... \textgreater{}               & \begin{tabular}[c]{@{}l@{}}Result type if used as callable for Args... (since\\ C++17)\end{tabular}                        \\ \hline
		result\_of\textless{}F,ArgTypes \textgreater{}                  & \begin{tabular}[c]{@{}l@{}}Result type if calling F with argument types ArgTypes\\ (deprecated since C++17)\end{tabular}   \\ \hline
	\end{tabular}
\end{table}

\begin{center}
Table D.3. Traits to Test Simple Type Properties
\end{center}

std::is\_volatile < T >::value

\begin{itemize}
\item 
Yields true if the type is volatile-qualified.

\item 
Note that a volatile pointer has a volatile-qualified type, whereas a non-volatile pointer or a reference to a volatile type is not volatile-qualified. For example:

\begin{lstlisting}[style=styleCXX]
is_volatile<int* volatile>::value // true
is_volatile<int volatile*>::value // false
is_volatile<int volatile&>::value // false
\end{lstlisting}

\item 
The language defines arrays to be volatile-qualified if the element type is volatile-qualified.

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm}This was clarified by the resolution of core issue 1059 after C++11 was published.
\end{tcolorbox}

For example:
\begin{lstlisting}[style=styleCXX]
is_volatile<int[3]>::value // false
is_volatile<int volatile[3]>::value // true
is_volatile<int[]>::value // false
is_volatile<int volatile[]>::value // true
\end{lstlisting}
\end{itemize}

std::is\_aggregate < T >::value

\begin{itemize}
\item 
Yields true if T is an aggregate type (either an array or a class/struct/union that has no userdefined, explicit, or inherited constructors, no private or protected nonstatic data members, no virtual functions, and no virtual, private, or protected base classes).

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm}Note that the base classes and/or data members of aggregates don’t have to be aggregates. Prior to C++14, aggregate class types could not have default member initializers. Prior to C++17, aggregates could not have public base classes.
\end{tcolorbox}

\item 
Helps to find out whether list initialization is required. For example:
\begin{lstlisting}[style=styleCXX]
template<typename Coll, typename... T>
void insert(Coll& coll, T&&... val)
{
	if constexpr(!std::is_aggregate_v<typename Coll::value_type>) {
		coll.emplace_back(std::forward<T>(val)...); // invalid for aggregates
	}
	else {
		coll.emplace_back(typename Coll::value_type{std::forward<T>(val)...});
	}
}
\end{lstlisting}

\item 
Requires that the given type is either complete (see Section 10.3.1 on page 154) or (cv-qualified) void.

\item 
Available since C++17.
\end{itemize}

std::is\_trivial < T >::value

\begin{itemize}
\item 
Yields true if the type is a “trivial” type:

\begin{itemize}
\item [-]
a scalar type (integral, float, enum, pointer; see is\_scalar() on page 707)

\item [-]
a trivial class type (a class that has no virtual functions, no virtual base classes, no (indirectly) user-defined default constructor, copy/move constructor, copy/move assignment operator, or destructor, no initializer for nonstatic data members, no volatile members, and no nontrival members)

\item [-]
an array of such types

\item [-]
and cv-qualified versions of these types
\end{itemize}

\item 
Yields true if is\_trivially\_copyable\_v<T> yields true and a trivial default constructor exists.

\item 
Requires that the given type is either complete (see Section 10.3.1 on page 154) or (cv-qualified) void.
\end{itemize}

std::is\_trivially\_copyable < T >::value

\begin{itemize}
\item 
Yields true if the type is a “trivially copyable” type:

\begin{itemize}
\item [-]
a scalar type (integral, float, enum, pointer; see is\_scalar<> on page 707)

\item [-]
a trivial class type (a class that has no virtual functions, no virtual base classes, no (indirectly) user-defined default constructor, copy/move constructor, copy/move assignment operator, or destructor, no initializer for nonstatic data members, no volatile members, and no nontrival members)

\item [-]
an array of such types

\item [-]
and cv-qualified versions of these types
\end{itemize}

\item 
Yields the same as is\_trivial\_v<T> except it can produce true for a class type without a trivial default constructor.

\item 
In contrast to is\_standard\_layout<>, volatile members are not allowed, references are allowed, members might have different access, and members might be distributed among different (base) classes.

\item 
Requires that the given type is either complete (see Section 10.3.1 on page 154) or (cv-qualified) void.
\end{itemize}

std::is\_standard\_layout < T >::value

\begin{itemize}
\item 
Yields true if the type has a standard layout, which, for example, makes it easier to exchange values of this type with other languages.

\begin{itemize}
\item [-]
a scalar type (integral, float, enum, pointer; see is\_scalar<> on page 707)

\item [-]
a standard-layout class type (no virtual functions, no virtual base classes, no nonstatic reference members, all nonstatic members are in the same (base) class defined with the same access, all members are also standard-layout types)

\item [-]
an array of such types

\item [-]
and cv-qualified versions of these types
\end{itemize}

\item 
In contrast to is\_trivial<>, volatile members are allowed, references are not allowed, members might not have different access, and members might not be distributed among different (base) classes.

\item 
Requires that the given type (for arrays, the basic type) is either complete (see Section 10.3.1 on page 154) or (cv-qualified) void.
\end{itemize}

\subsubsubsection{D.3.2\hspace{0.2cm}Test for Specific Operations}

\subsubsubsection{D.3.3\hspace{0.2cm}Relationships Between Types}