
Overload resolution ranks the viable candidate functions by comparing how each argument of the call matches the corresponding parameter of the candidates. For one candidate to be considered better than another, the better candidate cannot have any of its parameters be a worse match than the corresponding parameter in the other candidate. The following example illustrates this:

\begin{lstlisting}[style=styleCXX]
void combine(int, double);
void combine(long, int);

int main()
{
	combine(1, 2); // ambiguous!
}
\end{lstlisting}

In this example, the call to combine() is ambiguous because the first candidate matches the first argument (the literal 1 of type int) best, whereas the second candidate matches the second argument best. We could argue that int is in some sense closer to long than to double (which supports choosing the second candidate), but C++ does not attempt to define a measure of closeness that involves multiple call arguments.

Given this first principle, we are left with specifying how well a given argument matches the corresponding parameter of a viable candidate. As a first approximation, we can rank the possible matches as follows (from best to worst):

\begin{enumerate}
\item 
Perfect match. The parameter has the type of the expression, or it has a type that is a reference to the type of the expression (possibly with added const and/or volatile qualifiers).

\item 
Match with minor adjustments. This includes, for example, the decay of an array variable to a pointer to its first element or the addition of const to match an argument of type int** to a parameter of type int const* const*.


\item 
Match with promotion. Promotion is a kind of implicit conversion that includes the conversion of small integral types (such as bool, char, short, and sometimes enumerations) to int, unsigned int, long, or unsigned long, and the conversion of float to double.


\item 
Match with standard conversions only. This includes any sort of standard conversion (such as int to float) or conversion from a derived class to one of its public, unambiguous base classes but excludes the implicit call to a conversion operator or a converting constructor.


\item 
Match with user-defined conversions. This allows any kind of implicit conversion.


\item 
Match with ellipsis (...). An ellipsis parameter can match almost any type. However, there is one exception: Class types with a nontrivial copy constructor may or may not be valid (implementations are free to allow or disallow this).
\end{enumerate}

The following contrived example illustrates some of these matches:

\begin{lstlisting}[style=styleCXX]
int f1(int); // #1
int f1(double); // #2
f1(4); // calls #1 : perfect match (#2 requires a standard conversion)

int f2(int); // #3
int f2(char); // #4
f2(true); // calls #3 : match with promotion
// (#4 requires stronger standard conversion)

class X {
	public:
	X(int);
};
int f3(X); // #5
int f3(...); // #6
f3(7); // calls #5 : match with user-defined conversion
// (#6 requires a match with ellipsis)
\end{lstlisting}

Note that overload resolution occurs after template argument deduction, and this deduction does not consider all these sorts of conversions. For example:

\begin{lstlisting}[style=styleCXX]
template<typename T>
class MyString {
	public:
	MyString(T const*); // converting constructor
	...
};

template<typename T>
MyString<T> truncate(MyString<T> const&, int);

int main()
{
	MyString<char> str1, str2;
	str1 = truncate<char>("Hello World", 5); // OK
	str2 = truncate("Hello World", 5); // ERROR
}
\end{lstlisting}

The implicit conversion provided through the converting constructor is not considered during template argument deduction. The assignment to str2 finds no viable function truncate(); hence overload resolution is not performed at all.

In the context of template argument deduction, recall also that an rvalue reference to a template parameter can deduce to either an lvalue reference type (after reference collapsing) if the corresponding argument is an lvalue or to an rvalue reference type if that argument is an rvalue (see Section 15.6 on page 277). For example:

\begin{lstlisting}[style=styleCXX]
template<typename T> void strange(T&&, T&&);
template<typename T> void bizarre(T&&, double&&);

int main()
{
	strange(1.2, 3.4); // OK: with T deduced to double
	double val = 1.2;
	strange(val, val); // OK: with T deduced to double&
	strange(val, 3.4); // ERROR: conflicting deductions
	bizarre(val, val); // ERROR: lvalue val doesn’t match double&&
}
\end{lstlisting}

The previous principles are only a first approximation, but they cover many cases. Yet there are quite a few common situations that are not adequately explained by these rules. We proceed with a brief discussion of the most important refinements of these rules.

\subsubsubsection{C.2.1\hspace{0.2cm}The Implied Argument for Member Functions}

Calls to nonstatic member functions have a hidden parameter that is accessible in the definition of the member function as *this. For a member function of a class MyClass, the hidden parameter is usually of type MyClass\& (for non-const member functions) or MyClass const\& (for const member functions).

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm} It could also be of type MyClass volatile\& or MyClass const volatile\& if the member function was volatile, but this is extremely rare.
\end{tcolorbox}

This is somewhat surprising given that this has a pointer type. It would have been nicer to make this equivalent to what is now *this. However, this was part of an early version of C++ before reference types were part of the language, and by the time reference types were added, too much code already depended on this being a pointer.

The hidden *this parameter participates in overload resolution just like the explicit parameters.Most of the time this is quite natural, but occasionally it comes unexpectedly. The following example shows a string-like class that does not work as intended (yet we have seen such code in the real world):

\begin{lstlisting}[style=styleCXX]
#include <cstddef>

class BadString {
	public:
	BadString(char const*);
	...
	
	// character access through subscripting:
	char& operator[] (std::size_t); // #1
	char const& operator[] (std::size_t) const;
	
	// implicit conversion to null-terminated byte string:
	operator char* (); // #2
	operator char const* ();
	...
};

int main()
{
	BadString str("correkt");
	str[5] = ’c’; // possibly an overload resolution ambiguity!
}
\end{lstlisting}

At first, nothing seems ambiguous about the expression str[5]. The subscript operator at \#1 seems like a perfect match. However, it is not quite perfect because the argument 5 has type int, and the operator expects an unsigned integer type (size\_t and std::size\_t usually have type unsigned int or unsigned long, but never type int). Still, a simple standard integer conversion makes \#1 easily viable. However, there is another viable candidate: the built-in subscript operator. Indeed, if we apply the implicit conversion operator to str (which is the implicit member function argument), we obtain a pointer type, and now the built-in subscript operator applies. This built-in operator takes an argument of type ptrdiff\_t, which on many platforms is equivalent to int and therefore is a perfect match for the argument 5. So even though the built-in subscript operator is a poor match (by user-defined conversion) for the implied argument, it is a better match than the operator defined at \#1 for the actual subscript! Hence the potential ambiguity.

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm}Note that the ambiguity exists only on platforms for which size\_t is a synonym for unsigned int. On platforms for which it is a synonym for unsigned long, the type ptrdiff\_t is a type alias of long, and no ambiguity exists because the built-in subscript operator also requires a conversion of the subscript expression.
\end{tcolorbox}

To solve this kind of problem portably, you can declare operator [ ] with a ptrdiff\_t parameter, or you can replace the implicit type conversion to char* by an explicit conversion (which is usually recommended anyway).

It is possible for a set of viable candidates to contain both static and nonstatic members. When comparing a static member with a nonstatic member, the quality of the match of the implicit argument is ignored (only the nonstatic member has an implicit *this parameter).

By default, a nonstatic member function has an implicit *this parameter that is an lvalue reference type, but C++11 introduced syntax to make it an rvalue reference type. For example:

\begin{lstlisting}[style=styleCXX]
struct S {
	void f1(); // implicit *this parameter is an lvalue reference (see below)
	void f2() &&; // implicit *this parameter is an rvalue reference
	void f3() &; // implicit *this parameter is an lvalue reference
};
\end{lstlisting}

As you can tell from this example, it is possible not only to make the implicit parameter an rvalue reference (with the \&\& suffix) but also to affirm the lvalue reference case (with the \& suffix). Interestingly, specifying the \& suffix is not exactly equivalent to leaving it off: An old special-case permits an rvalue to be bound to an lvalue reference to non-const type when that reference is the traditional implicit *this parameter, but that (somewhat dangerous) special case no longer applies if the lvalue reference treatment was requested explicitly. So, with the definition of S specified above:

\begin{lstlisting}[style=styleCXX]
int main()
{
	S().f1(); // OK: old rule allows rvalue S() to match implied
			// lvalue reference type S& of *this
	S().f2(); // OK: rvalue S() matches rvalue reference type
			// of *this
	S().f3(); // ERROR: rvalue S() cannot match explicit lvalue
			// reference type of *this
}
\end{lstlisting}


\subsubsubsection{C.2.2\hspace{0.2cm}Refining the Perfect Match}

For an argument of type X, there are four common parameter types that constitute a perfect match: X, X\&, X const\&, and X\&\& (X const\&\& is also an exact match, but it is rarely used). However, it is rather common to overload a function on two kinds of references. Prior to C++11, this meant cases like these:

\begin{lstlisting}[style=styleCXX]
void report(int&); // #1
void report(int const&); // #2

int main()
{
	for (int k = 0; k<10; ++k) {
		report(k); // calls #1
	}
	report(42); // calls #2
}
\end{lstlisting}

Here, the version without the extra const is preferred for lvalues, whereas only the version with const can match rvalues.

With the addition of rvalue references in C++11, another common case of two perfect matches needing to be distinguished is illustrated by the following example:

\begin{lstlisting}[style=styleCXX]
struct Value {
	...
};
void pass(Value const&); // #1
void pass(Value&&); // #2

void g(X&& x)
{
	pass(x); // calls #1 , because x is an lvalue
	pass(X()); // calls #2 , because X() is an rvalue (in fact, prvalue)
	pass(std::move(x)); // calls #2 , because std::move(x) is an rvalue (in fact, xvalue)
}
\end{lstlisting}

This time, the version taking an rvalue reference is considered a better match for rvalues, but it cannot match lvalues.

Note that this also applies to the implicit argument of a member function call:

\begin{lstlisting}[style=styleCXX]
class Wonder {
	public:
	void tick(); // #1
	void tick() const; // #2
	void tack() const; // #3
};

void run(Wonder& device)
{
	device.tick(); // calls #1
	device.tack(); // calls #3 , because there is no non-const version
				  // of Wonder::tack()
}
\end{lstlisting}

Finally, the following modification of our earlier example illustrates that two perfect matches can also create an ambiguity if you overload with and without references:

\begin{lstlisting}[style=styleCXX]
void report(int); // #1
void report(int&); // #2
void report(int const&); // #3

int main()
{
	for (int k = 0; k<10; ++k) {
		report(k); // ambiguous: #1 and #2 match equally well
	}
report(42); // ambiguous: #1 and #3 match equally well
}
\end{lstlisting}








