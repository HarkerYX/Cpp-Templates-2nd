
A tuples is a container that provides the ability to access and modify each of its elements (through get) as well as to create new tuples (directly or with makeTuple()) and to break a tuple into its head and tail (getHead() and getTail()). These fundamental building blocks are sufficient to build a suite of tuple algorithms, such as adding or removing elements from a tuple, reordering the elements in a tuple, or selecting some subset of the elements in the tuple.

Tuple algorithms are particularly interesting because they require both compile-time and run-time computation. Like the typelist algorithms of Chapter 24, applying an algorithm to a tuple may result in a tuple with a completely different type, which requires compile-time computation. For example, reversing a Tuple<int, double, string> produces a Tuple<string, double, int>. However, like an algorithm for a homogeneous container (e.g., std::reverse() on a std::vector), tuple algorithms actually require code to execute at run time, and we need to be mindful of the efficiency of the generated code.

\subsubsubsection{25.3.1\hspace{0.2cm}Tuples as Typelists}

If we ignore the actual run-time component of our Tuple template, we see that it has precisely the same structure as the Typelist template developed in Chapter 24: It accepts any number of template type parameters. In fact, with a few partial specializations, we can turn Tuple into a full-featured typelist:

\hspace*{\fill} \\ %插入空行
\noindent
\textit{tuples/tupletypelist.hpp}
\begin{lstlisting}[style=styleCXX]
// determine whether the tuple is empty:
template<>
struct IsEmpty<Tuple<>> {
	static constexpr bool value = true;
};

// extract front element:
template<typename Head, typename... Tail>
class FrontT<Tuple<Head, Tail...>> {
	public:
	using Type = Head;
};

// remove front element:
template<typename Head, typename... Tail>
class PopFrontT<Tuple<Head, Tail...>> {
	public:
	using Type = Tuple<Tail...>;
};

// add element to the front:
template<typename... Types, typename Element>
class PushFrontT<Tuple<Types...>, Element> {
	public:
	using Type = Tuple<Element, Types...>;
};

// add element to the back:
template<typename... Types, typename Element>
class PushBackT<Tuple<Types...>, Element> {
	public:
	using Type = Tuple<Types..., Element>;
};
\end{lstlisting}

Now, all of the typelist algorithms developed in Chapter 24 work equally well with Tuple and Typelist, so that we easily can deal with the type of tuples. For example:

\begin{lstlisting}[style=styleCXX]
Tuple<int, double, std::string> t1(17, 3.14, "Hello, World!");
using T2 = PopFront<PushBack<decltype(t1), bool>>;
T2 t2(get<1>(t1), get<2>(t1), true);
std::cout << t2;
\end{lstlisting}

which prints:

\begin{tcblisting}{commandshell={}}
(3.14, Hello, World!, 1)
\end{tcblisting}

As we will see shortly, typelist algorithms applied to tuple types are often used to help determine the result type of a tuple algorithm.

\subsubsubsection{25.3.2\hspace{0.2cm}Adding to and Removing from a Tuple}

For the values of tuples, the ability to add an element to the beginning or end of a tuple is important for building more advanced algorithms. As with typelists, insertion at the front of a tuple is far easier than insertion at the back, so we start with pushFront:

\hspace*{\fill} \\ %插入空行
\noindent
\textit{typelist/pushfront.hpp}
\begin{lstlisting}[style=styleCXX]
template<typename... Types, typename V>
PushFront<Tuple<Types...>, V>
pushFront(Tuple<Types...> const& tuple, V const& value)
{
	return PushFront<Tuple<Types...>, V>(value, tuple);
}
\end{lstlisting}

Adding a new element (called value) onto the front of an existing tuple requires us to form a new tuple with value as its head and the existing tuple as its tail. The resulting tuple type is Tuple<V, Types...>. However, we have opted to use the typelist algorithm PushFront to demonstrate the tight coupling between the compile-time and run-time aspects of tuple algorithms: The compile-time PushFront computes the type that we need to construct to produce the appropriate run-time value.

Adding a new element to the end of an existing tuple is more complicated, because it requires a recursive walk of the tuple, building up the modified tuple as we go. Note how the structure of the pushBack() implementation follows the recursive formulation of the typelist PushBack() from Section 24.2.3 on page 555:

\hspace*{\fill} \\ %插入空行
\noindent
\textit{typelist/pushback.hpp}
\begin{lstlisting}[style=styleCXX]
// basis case
template<typename V>
Tuple<V> pushBack(Tuple<> const&, V const& value)
{
	return Tuple<V>(value);
}

// recursive case
template<typename Head, typename... Tail, typename V>
Tuple<Head, Tail..., V>
pushBack(Tuple<Head, Tail...> const& tuple, V const& value)
{
	return Tuple<Head, Tail..., V>(tuple.getHead(),
	pushBack(tuple.getTail(), value));
}
\end{lstlisting}

The basis case, as expected, appends a value to a zero-length tuple by producing a tuple containing just that value. In the recursive case, we form a new tuple from the current element at the beginning of the list (tuple.getHead()) and the result of adding the new element to the tail of the list (the recursive pushBack call). While we have opted to express the constructed type as Tuple<Head, Tail..., V>, we note that this is equivalent to using the compile-time PushBack<Tuple<Head, Tail...>, V>.

Also, popFront() is easy to implement:

\hspace*{\fill} \\ %插入空行
\noindent
\textit{typelist/popfront.hpp}
\begin{lstlisting}[style=styleCXX]
template<typename... Types>
PopFront<Tuple<Types...>>
popFront(Tuple<Types...> const& tuple)
{
	return tuple.getTail();
}
\end{lstlisting}

Now we can program the example from Section 25.3.1 on page 582 as follows:

\begin{lstlisting}[style=styleCXX]
Tuple<int, double, std::string> t1(17, 3.14, "Hello, World!");
auto t2 = popFront(pushBack(t1, true));
std::cout << std::boolalpha << t2 << ’\n’;
\end{lstlisting}

which prints

\begin{tcblisting}{commandshell={}}
(3.14, Hello, World!, true)
\end{tcblisting}

\subsubsubsection{25.3.3\hspace{0.2cm}Reversing a Tuple}

The elements of a tuple can be reversed with another recursive tuple algorithm whose structure follows that of the typelist reverse of Section 24.2.4 on page 557:

\hspace*{\fill} \\ %插入空行
\noindent
\textit{typelist/reverse.hpp}
\begin{lstlisting}[style=styleCXX]
// basis case
Tuple<> reverse(Tuple<> const& t)
{
	return t;
}

// recursive case
template<typename Head, typename... Tail>
Reverse<Tuple<Head, Tail...>> reverse(Tuple<Head, Tail...> const& t)
{
	return pushBack(reverse(t.getTail()), t.getHead());
}
\end{lstlisting}

The basis case is trivial, while the recursive case reverses the tail of the list and appends the current head to the reversed list. This means, for example, that

\begin{lstlisting}[style=styleCXX]
reverse(makeTuple(1, 2.5, std::string("hello")))
\end{lstlisting}

will produce a Tuple<string, double, int> with the values string("hello"), 2.5, and 1, respectively.

As with typelists, that way we can now easily provide popBack() by calling popFront() for the temporarily reversed list using PopBack from Section 24.2.4 on page 558:

\hspace*{\fill} \\ %插入空行
\noindent
\textit{typelist/popback.hpp}
\begin{lstlisting}[style=styleCXX]
template<typename... Types>
PopBack<Tuple<Types...>>
popBack(Tuple<Types...> const& tuple)
{
	return reverse(popFront(reverse(tuple)));
}
\end{lstlisting}

\subsubsubsection{25.3.4\hspace{0.2cm}Index Lists}

The recursive formulation of tuple reversal in the previous section is correct, but it is unnecessarily inefficient at run time. To see the problem, we introduce a simple class that counts the number of times it is copied:

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm}Before C++17, inline static members were not supported. So, we had to initialize numCopies outside the class structure in one translation unit.
\end{tcolorbox}

\hspace*{\fill} \\ %插入空行
\noindent
\textit{typelist/copycounter.hpp}
\begin{lstlisting}[style=styleCXX]
template<int N>
struct CopyCounter
{
	inline static unsigned numCopies = 0;
	CopyCounter() {
	}
	CopyCounter(CopyCounter const&) {
		++numCopies;
	}
};
\end{lstlisting}

Then, we create and reverse a tuple of CopyCounter instances:

\hspace*{\fill} \\ %插入空行
\noindent
\textit{typelist/copycountertest.hpp}
\begin{lstlisting}[style=styleCXX]
void copycountertest()
{
	Tuple<CopyCounter<0>, CopyCounter<1>, CopyCounter<2>,
			CopyCounter<3>, CopyCounter<4>> copies;
	auto reversed = reverse(copies);
	std::cout << "0: " << CopyCounter<0>::numCopies << " copies\n";
	std::cout << "1: " << CopyCounter<1>::numCopies << " copies\n";
	std::cout << "2: " << CopyCounter<2>::numCopies << " copies\n";
	std::cout << "3: " << CopyCounter<3>::numCopies << " copies\n";
	std::cout << "4: " << CopyCounter<4>::numCopies << " copies\n";
}
\end{lstlisting}

This program will output:

\begin{tcblisting}{commandshell={}}
0: 5 copies
1: 8 copies
2: 9 copies
3: 8 copies
4: 5 copies
\end{tcblisting}

That’s a lot of copies! In the ideal implementation of tuple reverse, each element would only be copied a single time, from the source tuple directly to the correct position in the result tuple. We could achieve this goal with careful use of references, including using references for the types of the intermediate arguments, but doing so complicates our implementation considerably.

To eliminate extraneous copies in tuple reverse, consider how we might implement a one-off tuple reverse operation for a single tuple of known length (say, 5 elements, as in our example). We could simply use makeTuple() and get():

\begin{lstlisting}[style=styleCXX]
auto reversed = makeTuple(get<4>(copies), get<3>(copies),
							get<2>(copies), get<1>(copies),
							get<0>(copies));
\end{lstlisting}

This program produces the exact output that we want, with a single copy of each tuple element:

\begin{tcblisting}{commandshell={}}
0: 1 copies
1: 1 copies
2: 1 copies
3: 1 copies
4: 1 copies
\end{tcblisting}

Index lists (also called index sequences; see Section 24.4 on page 570) generalize this notion by capturing the set of tuple indices—in this case 4, 3, 2, 1, 0—into a parameter pack, which allows the sequence of get calls to be produced via a pack expansion. This allows the separation of the index computation, which can be an arbitrarily complicated template metaprogram, from the actual application of that index list, where run-time efficiency is most important. The standard type std::integer\_sequence (introduced in C++14) is often used to represent index lists.

\subsubsubsection{25.3.5\hspace{0.2cm}Reversal with Index Lists}

To perform tuple reversal with index lists, we first need a representation of index lists. An index list is a typelist containing values meant to be used as indices into either a typelist or a heterogeneous data structure (see Section 24.4 on page 570). For our index list, we will use the Valuelist type developed in Section 24.3 on page 566. The index list corresponding to the tuple reversal example above would be

\begin{lstlisting}[style=styleCXX]
Valuelist<unsigned, 4, 3, 2, 1, 0>
\end{lstlisting}

How do we produce this index list? One approach would be to start by generating an index list counting upward from 0 to N − 1 (inclusive), where N is the length of a tuple, using a simple template metaprogram MakeIndexList:

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm}C++14 provides a similar template make\_index\_sequence that yields a list of indices of type std::size\_t, as well as a more general make\_integer\_sequence that allows the specific type to be selected.
\end{tcolorbox}

\hspace*{\fill} \\ %插入空行
\noindent
\textit{typelist/makeindexlist.hpp}
\begin{lstlisting}[style=styleCXX]
// recursive case
template<unsigned N, typename Result = Valuelist<unsigned>>
struct MakeIndexListT
: MakeIndexListT<N-1, PushFront<Result, CTValue<unsigned, N-1>>>
{
};

// basis case
template<typename Result>
struct MakeIndexListT<0, Result>
{
	using Type = Result;
};

template<unsigned N>
using MakeIndexList = typename MakeIndexListT<N>::Type;
\end{lstlisting}

We can then compose this operation with the typelist Reverse to produce the appropriate index list:

\begin{lstlisting}[style=styleCXX]
using MyIndexList = Reverse<MakeIndexList<5>>;
					// equivalent to Valuelist<unsigned, 4, 3, 2, 1, 0>
\end{lstlisting}

To actually perform the reversal, the indices in the index list need to be captured into a nontype parameter pack. This is handled by splitting the implementation of the index-set tuple reverse() algorithm into two parts:

\hspace*{\fill} \\ %插入空行
\noindent
\textit{typelist/indexlistreverse.hpp}
\begin{lstlisting}[style=styleCXX]
template<typename... Elements, unsigned... Indices>
auto reverseImpl(Tuple<Elements...> const& t,
Valuelist<unsigned, Indices...>)
{
	return makeTuple(get<Indices>(t)...);
}

template<typename... Elements>
auto reverse(Tuple<Elements...> const& t)
{
	return reverseImpl(t,
	Reverse<MakeIndexList<sizeof...(Elements)>>());
}
\end{lstlisting}

In C++11, the return types have to be declared as

\begin{lstlisting}[style=styleCXX]
-> decltype(makeTuple(get<Indices>(t)...))
\end{lstlisting}

and

\begin{lstlisting}[style=styleCXX]
-> decltype(reverseImpl(t, Reverse<MakeIndexList<sizeof...(Elements)>>()))
\end{lstlisting}

The reverseImpl() function template captures the indices from its Valuelist parameter into a parameter pack Indices. It then returns the result of calling makeTuple() with arguments formed by calling get() on the tuple with the set of captured indices.

The reverse() algorithm itself merely forms the appropriate index set, as discussed earlier, and provides that to the reverseImpl algorithm. The indices are manipulated as a template metaprogram and therefore produce no run-time code. The only run-time code is in reverseImpl, which uses makeTuple() to construct the resulting tuple in one step and therefore copies the tuple elements only a single time.

\subsubsubsection{25.3.6\hspace{0.2cm}Shuffle and Select}

The reverseImpl() function template used in the previous section to form the reversed tuple actually contains no code specific to the reverse() operation. Rather, it simply selects a particular set of indices from an existing tuple and uses them to form a new tuple. reverse() provides a reversed set of indices, but many algorithms can build on this core tuple select() algorithm:

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm}In C++11, the return type has to be declared as -> decltype(makeTuple(get<Indices>(t)...)).
\end{tcolorbox}

\hspace*{\fill} \\ %插入空行
\noindent
\textit{typelist/select.hpp}
\begin{lstlisting}[style=styleCXX]
template<typename... Elements, unsigned... Indices>
auto select(Tuple<Elements...> const& t,
			Valuelist<unsigned, Indices...>)
{
	return makeTuple(get<Indices>(t)...);
}
\end{lstlisting}

One simple algorithm that builds on select() is a tuple “splat” operation, which takes a single element in a tuple and replicates it to create another tuple with some number of copies of that element. For example:

\begin{lstlisting}[style=styleCXX]
Tuple<int, double, std::string> t1(42, 7.7, "hello"};
auto a = splat<1, 4>(t);
std::cout << a << ’\n’;
\end{lstlisting}

would produce a Tuple<double, double, double, double> where each of the values is a copy of get<1>(t), so it will print

\begin{lstlisting}[style=styleCXX]
(7.7, 7.7, 7.7, 7.7)
\end{lstlisting}

Given a metaprogram to produce a “replicated” index set consisting of N copies of the value I, splat() is a direct application of select():

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm}In C++11, the return type of splat() has to be declared as -> decltype(return-expression).
\end{tcolorbox}

\hspace*{\fill} \\ %插入空行
\noindent
\textit{typelist/splat.hpp}
\begin{lstlisting}[style=styleCXX]
template<unsigned I, unsigned N, typename IndexList = Valuelist<unsigned>>
class ReplicatedIndexListT;

template<unsigned I, unsigned N, unsigned... Indices>
class ReplicatedIndexListT<I, N, Valuelist<unsigned, Indices...>>
: public ReplicatedIndexListT<I, N-1,
								Valuelist<unsigned, Indices..., I>> {
};

template<unsigned I, unsigned... Indices>
class ReplicatedIndexListT<I, 0, Valuelist<unsigned, Indices...>> {
	public:
	using Type = Valuelist<unsigned, Indices...>;
};

template<unsigned I, unsigned N>
using ReplicatedIndexList = typename ReplicatedIndexListT<I, N>::Type;

template<unsigned I, unsigned N, typename... Elements>
auto splat(Tuple<Elements...> const& t)
{
	return select(t, ReplicatedIndexList<I, N>());
}
\end{lstlisting}

Even complicated tuple algorithms can also be implemented in terms of a template metaprogram on the index list followed by an application of select(). For example, we can use the insertion sort developed in Section 24.2.7 on page 563 to sort a tuple based on the sizes of the element types. Given such a sort() function, which accepts a template metafunction comparing tuple element types as the comparison operation, we could sort tuple elements by size with code like the following:

\hspace*{\fill} \\ %插入空行
\noindent
\textit{typelist/tuplesorttest.hpp}
\begin{lstlisting}[style=styleCXX]
#include <complex>

template<typename T, typename U>
class SmallerThanT
{
	public:
	static constexpr bool value = sizeof(T) < sizeof(U);
};

void testTupleSort()
{
	auto t1 = makeTuple(17LL, std::complex<double>(42,77), ’c’, 42, 7.7);
	std::cout << t1 << ’\n’;
	auto t2 = sort<SmallerThanT>(t1); // t2 is Tuple<int, long, std::string>
	std::cout << "sorted by size: " << t2 << ’\n’;
}
\end{lstlisting}

The output might, for example, be as follows:

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm}Note that the resulting order depends on the platform-specific size. For example, the size of a double might be less, the same, or greater than the size of a long long
\end{tcolorbox}

\begin{lstlisting}[style=styleCXX]
(17, (42,77), c, 42, 7.7)
sorted by size: (c, 42, 7.7, 17, (42,77))
\end{lstlisting}

The actual sort() implementation involves the use of InsertionSort with a tuple select():

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm}In C++11, the return type of sort() has to be declared as -> decltype(return-expression).
\end{tcolorbox}

\hspace*{\fill} \\ %插入空行
\noindent
\textit{tuples/tuplesort.hpp}
\begin{lstlisting}[style=styleCXX]
// metafunction wrapper that compares the elements in a tuple:
template<typename List, template<typename T, typename U> class F>
class MetafunOfNthElementT {
	public:
	template<typename T, typename U> class Apply;
	template<unsigned N, unsigned M>
	class Apply<CTValue<unsigned, M>, CTValue<unsigned, N>>
	: public F<NthElement<List, M>, NthElement<List, N>> { };
};

// sort a tuple based on comparing the element types:
template<template<typename T, typename U> class Compare,
typename... Elements>
auto sort(Tuple<Elements...> const& t)
{
	return select(t,
					InsertionSort<MakeIndexList<sizeof...(Elements)>,
									MetafunOfNthElementT<
												Tuple<Elements...>,
												Compare>::template Apply>());
}
\end{lstlisting}

Look carefully at the use of InsertionSort: The actual typelist to be sorted is a list of indices into the typelist, constructed with MakeIndexList<>. Therefore, the result of the insertion sort is a set of indices into the tuple, which is then provided to select(). However, because the InsertionSort is operating on indices, it expects its comparison operation to compare two indices. The principle is easier to understand when considering a sort of the indices of a std::vector, as in the following (non-metaprogramming) example:

\hspace*{\fill} \\ %插入空行
\noindent
\textit{tuples/indexsort.hpp}
\begin{lstlisting}[style=styleCXX]
#include <vector>
#include <algorithm>
#include <string>

int main()
{
	std::vector<std::string> strings = {"banana", "apple", "cherry"};
	std::vector<unsigned> indices = { 0, 1, 2 };
	std::sort(indices.begin(), indices.end(),
			[&strings](unsigned i, unsigned j) {
				return strings[i] < strings[j];
			});
}
\end{lstlisting}

Here, indices contains indices into the vector strings. The sort() operation sorts the actual indices, so the lambda provided as the comparison operation accepts two unsigned values (rather than string values). However, the body of the lambda uses those unsigned values as indices into the strings vector, so the ordering is actually according to the contents of strings. At the end of the sort, indices provides indices into strings, sorted based on the values in strings.

Our use of InsertionSort for the tuple sort() employs the same approach. The adapter template MetafunOfNthElementT provides a template metafunction (its nested Apply) that accepts two indices (CTValue specializations) and uses NthElement to extract the corresponding elements from its Typelist argument. In a sense, the member template Apply has “captured” the typelist provided to its enclosing template (MetafunOfNthElementT) in the same way that the lambda captured the strings vector from its enclosing scope. Apply then forwards the extracted element types to the underlying metafunction F, completing the adaptation.

Note that all of the computation for the sort is performed at compile time, and the resulting tuple is formed directly, with no extraneous copying of values at run time.

















