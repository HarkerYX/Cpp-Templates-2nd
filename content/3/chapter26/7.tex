Andrei Alexandrescu covered discriminated unions in detail in a series of articles [AlexandrescuDiscriminatedUnions]. Our treatment of Variant relies on some of the same techniques such as aligned buffers for in-place storage and visitation to extract values. Some of the differences are due to the base language: Andrei was working with C++98, so, for example, it cannot make use of variadic templates or inheriting constructors. Andrei also devotes considerable time to the computation of alignment, which C++11 made trivial with the introduction of alignas. The most interesting design difference is in the handling of the discriminator: While we opted to use an integral discriminator to indicate which type was currently stored in the variant, Andrei employs a “static vtable” approach using function pointers to construct, copy, query, and destroy the underlying element type. Interestingly, this static vtable approach has been more influential as an optimization technique for open discriminated unions like the FunctionPtr template, developed in Section 22.2 on page 519, and is a common optimization for implementations of std::function to eliminate the use of virtual functions. Boost’s any type ([BoostAny]) is another open discriminated union type, which was adopted by the standard library as std::any in C++17.

Later, the Boost libraries ([Boost]) introduced several discriminated union types, including a variant type ([BoostVariant]) that influenced the one developed in this chapter. The design documentation for Boost.Variant ([BoostVariant]) includes a fascinating discussion of the exception-safety issue with variant assignment (referred as the “never-empty guarantee”) and the various not-entirely-satisfying solutions to the problem. When adopted by the standard library as std::variant with C++17 the never-empty guarantee was given up: The need to allocate heap storage for backups was removed by allowing that the std::variant state can become valueless\_by\_exception provided assigning a new value to it throws, a behavior we model with our empty variants.

Unlike our Variant template, std::variant allows multiple identical template arguments (e.g., std::variant<int, int>). Enabling that functionality in Variant would require significant changes in our design, including adding a method to disambiguate the VariantChoice base classes and an alternative to the nested pack expansion described in Section 26.2 on page 608.

The variant visit() operation described in this chapter is structurally identical to the ad hoc visitor pattern described by Andrei Alexandrescu in [AlexandrescuAdHocVisitor]. Alexandrescu’s ad hoc visitor is intended to simplify the process of checking a pointer to some common base class against
some set of known derived classes (described as a typelist). The implementation uses dynamic\_cast to test the pointer against each derived class in the typelist, calling the visitor with the derived class pointer when it finds a match.



