
The is() and get() member functions allow us to check whether the active value is of a specific type and access a value with that type. However, inspecting all of the possible types within a variant quickly devolves into a redundant chain of if statements. For example, the following prints the value of a Variant<int, double, string> named v:

\begin{lstlisting}[style=styleCXX]
if (v.is<int>()) {
	std::cout << v.get<int>();
}
else if (v.is<double>()) {
	std::cout << v.get<double>();
}
else {
	std::cout << v.get<string>();
}
\end{lstlisting}

To generalize this to print the value stored in an arbitrary variant requires a recursively instantiated function template along with a helper. For example:

\hspace*{\fill} \\ %插入空行
\noindent
\textit{variant/printrec.cpp}
\begin{lstlisting}[style=styleCXX]
#include "variant.hpp"
#include <iostream>

template<typename V, typename Head, typename... Tail>
void printImpl(V const& v)
{
	if (v.template is<Head>()) {
		std::cout << v.template get<Head>();
	}
	else if constexpr (sizeof...(Tail) > 0) {
		printImpl<V, Tail...>(v);
	}
}

template<typename... Types>
void print(Variant<Types...> const& v)
{
	printImpl<Variant<Types...>, Types...>(v);
}

int main() {
	Variant<int, short, float, double> v(1.5);
	print(v);
}
\end{lstlisting}

This is a significant amount of code for a relatively simple operation. To simplify this, we turn the problem around by extending Variant with a visit() operation. The client then passes in a visitor function object whose operator() will be invoked with the active value. Because the active value could be any one of the variant’s potential types, this operator() is likely either to be overloaded or itself a function template. For example, a generic lambda provides a templated operator(), allowing us to concisely represent the print operation for a variant v:

\begin{lstlisting}[style=styleCXX]
v.visit([](auto const& value) {
			std::cout << value;
		});
\end{lstlisting}

This generic lambda is roughly equivalent to the following function object, which can also be useful for compilers that do not yet support generic lambdas:

\begin{lstlisting}[style=styleCXX]
class VariantPrinter {
	public:
	template<typename T>
	void operator()(T const& value) const
	{
		std::cout << value;
	}
};
\end{lstlisting}

The core of the visit() operation is similar to the recursive print operation: It steps through the types of the Variant, checking whether the active value has the given type (with is<T>()), and then acts when it has found the appropriate type:

\hspace*{\fill} \\ %插入空行
\noindent
\textit{variant/variantvisitimpl.hpp}
\begin{lstlisting}[style=styleCXX]
template<typename R, typename V, typename Visitor,
		 typename Head, typename... Tail>
R variantVisitImpl(V&& variant, Visitor&& vis, Typelist<Head, Tail...>) {
	if (variant.template is<Head>()) {
		return static_cast<R>(
		std::forward<Visitor>(vis)(
		std::forward<V>(variant).template get<Head>()));
	}
	else if constexpr (sizeof...(Tail) > 0) {
		return variantVisitImpl<R>(std::forward<V>(variant),
		std::forward<Visitor>(vis),
		Typelist<Tail...>());
	}
	else {
		throw EmptyVariant();
	}
}
\end{lstlisting}

variantVisitImpl() is a nonmember function template with a number of template parameters. The template parameter R describes the result type of the visitation operation, which we will return to later. V is the type of the variant and Visitor is the type of the visitor. Head and Tail are used to decompose the types in the Variant to effect recursion.

The first if performs a (run-time) check to determine whether the active value of the given variant is of type Head: If so, the value is extracted from the variant via get<Head>() and passed along to the visitor, terminating the recursion. The second if performs recursion when there are more elements to consider. If none of the types have matched, the variant does not contain a value,

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black]
\hspace*{0.75cm}This case is discussed in detail in Section 26.4.3 on page 613
\end{tcolorbox}

in which case the implementation throws the EmptyVariant exception.

Aside from the result type computation provided by VisitResult (which will be discussed in the next section), the visit() implementation is straightforward:

\hspace*{\fill} \\ %插入空行
\noindent
\textit{variant/variantvisit.hpp}
\begin{lstlisting}[style=styleCXX]
template<typename... Types>
	template<typename R, typename Visitor>
VisitResult<R, Visitor, Types&...>
Variant<Types...>::visit(Visitor&& vis)& {
	using Result = VisitResult<R, Visitor, Types&...>;
	return variantVisitImpl<Result>(*this, std::forward<Visitor>(vis),
									Typelist<Types...>());
}

template<typename... Types>
template<typename R, typename Visitor>
VisitResult<R, Visitor, Types const&...>
Variant<Types...>::visit(Visitor&& vis) const& {
	using Result = VisitResult<R, Visitor, Types const &...>;
	return variantVisitImpl<Result>(*this, std::forward<Visitor>(vis),
									Typelist<Types...>());
}

template<typename... Types>
template<typename R, typename Visitor>
VisitResult<R, Visitor, Types&&...>
Variant<Types...>::visit(Visitor&& vis) && {
	using Result = VisitResult<R, Visitor, Types&&...>;
	return variantVisitImpl<Result>(std::move(*this),
									std::forward<Visitor>(vis),
									Typelist<Types...>());
}
\end{lstlisting}

The implementations delegate to variantVisitImpl directly, passing along the variant itself, forwarding the visitor, and supplying the complete list of types. The only differences between the three implementations are whether they pass the variant itself as Variant\&, Variant const\&, or Variant\&\&.

\subsubsubsection{26.5.1\hspace{0.2cm}Visit Result Type}

The result type of visit() remains a mystery. A given visitor might have different operator() overloads that produce different result types, a templated operator() whose result type is dependent on its parameter type, or some combination thereof. For example, consider the following generic lambda:

\begin{lstlisting}[style=styleCXX]
[](auto const& value) {
	return value + 1;
}
\end{lstlisting}

The result type of this lambda depends on the input type: given an int, it will produce a int, but given a double, it will produce a double. If this generic lambda were passed to the visit() operation of a Variant<int, double>, what should the result be?

There is no single correct answer, so our visit() operation allows the result type to be explicitly provided. For example, one might want to capture the results in another Variant<int, double>. One can explicitly specify the result type to visit() as the first template argument:

\begin{lstlisting}[style=styleCXX]
v.visit<Variant<int, double>>([](auto const& value) {
								return value + 1;
							});
\end{lstlisting}

The ability to explicitly specify the result type is important when there is no one-size-fits-all solution. However, requiring that the result type be explicitly specified in all cases can be verbose. Therefore, visit() provides both options using the combination of a default template argument and a simple metaprogram. Recall the declaration of visit():

\begin{lstlisting}[style=styleCXX]
template<typename R = ComputedResultType, typename Visitor>
VisitResult<R, Visitor, Types&...> visit(Visitor&& vis) &;
\end{lstlisting}

The template parameter R, which we explicitly specified in the example above, also has a default argument so that it need not always be explicitly specified. That default argument is an incomplete sentinel type ComputedResultType:

\begin{lstlisting}[style=styleCXX]
class ComputedResultType;
\end{lstlisting}

To compute its result type, visit passes all of its template parameters along to VisitResult, an alias template that provides access to a new type trait VisitResultT:

\hspace*{\fill} \\ %插入空行
\noindent
\textit{variant/variantvisitresult.hpp}
\begin{lstlisting}[style=styleCXX]
// an explicitly-provided visitor result type:
template<typename R, typename Visitor, typename... ElementTypes>
class VisitResultT
{
	public:
	using Type = R;
};

template<typename R, typename Visitor, typename... ElementTypes>
using VisitResult =
typename VisitResultT<R, Visitor, ElementTypes...>::Type;
\end{lstlisting}

The primary definition of VisitResultT handles cases where the argument for R has been explicitly specified, so Type is defined to R. A separate partial specialization applies when R receives its default argument, ComputedResultType:

\begin{lstlisting}[style=styleCXX]
template<typename Visitor, typename... ElementTypes>
class VisitResultT<ComputedResultType, Visitor, ElementTypes...>
{
	...
}
\end{lstlisting}

This partial specialization is responsible for computing an appropriate result type for the common case, and is the subject of the next section.

\subsubsubsection{26.5.2\hspace{0.2cm}Common Result Type}

When calling a visitor that may produce different types for each of the variant’s element types, how can we combine those types into a single result type for visit()? There are some obvious cases—if the visitor returns the same type for each element type, that should be the result type of visit().

C++ already has a notion of a reasonable result type, which was introduced in Section 1.3.3 on page 12: In the ternary expression b ? x : y, the type of the expression is the common type between the types of x and y. For example, if x has type int and y has type double, the common type is double because int promotes to double. We can capture this notion of the common type in a type trait:

\hspace*{\fill} \\ %插入空行
\noindent
\textit{variant/commontype.hpp}
\begin{lstlisting}[style=styleCXX]
using std::declval;

template<typename T, typename U>
class CommonTypeT
{
	public:
	using Type = decltype(true? declval<T>() : declval<U>());
};

template<typename T, typename U>
using CommonType = typename CommonTypeT<T, U>::Type;
\end{lstlisting}

The notion of a common type extends to a set of types: The common type is a type to which all of the types in the set can promote. For our visitor, we want to compute the common type of the result types that the visitor will produce when called with each of the types in the variant:

\hspace*{\fill} \\ %插入空行
\noindent
\textit{variant/variantvisitresultcommon.hpp}
\begin{lstlisting}[style=styleCXX]
#include "accumulate.hpp"
#include "commontype.hpp"

// the result type produced when calling a visitor with a value of type T:
template<typename Visitor, typename T>
using VisitElementResult = decltype(declval<Visitor>()(declval<T>()));

// the common result type for a visitor called with each of the given element types:
template<typename Visitor, typename... ElementTypes>
class VisitResultT<ComputedResultType, Visitor, ElementTypes...>
{
	using ResultTypes =
		Typelist<VisitElementResult<Visitor, ElementTypes>...>;
	public:
	using Type =
		Accumulate<PopFront<ResultTypes>, CommonTypeT, Front<ResultTypes>>;
};
\end{lstlisting}

The VisitResult computation occurs in two stages. First, VisitElementResult computes the result type produced when calling the visitor with a value of  type T. This metafunction is applied to each of the given element types to determine all of the result  types that the visitor could produce, capturing the result in the typelist ResultTypes.

Next, the computation uses the Accumulate algorithm described in Section 24.2.6 on page 560 to apply the common-type computation to the typelist of result types. Its initial value (the third argument to Accumulate) is the first result type, which is combined via CommonTypeT with successive values from the remainder of the ResultTypes typelist. The end result is the common type to which all of the visitor’s result types can be converted, or an error if the result types are incompatible.

Since C++11, the standard library provides a corresponding type trait, std::common\_type<>, which uses this approach to yield the common type of an arbitrary number of passed types (see Section D.5 on page 732), effectively combining CommonTypeT and Accumulate. By using std::common\_type<>, the implementation of VisitResultT is simpler:

\hspace*{\fill} \\ %插入空行
\noindent
\textit{variant/variantvisitresultstd.hpp}
\begin{lstlisting}[style=styleCXX]
template<typename Visitor, typename... ElementTypes>
class VisitResultT<ComputedResultType, Visitor, ElementTypes...>
{
	public:
	using Type =
		std::common_type_t<VisitElementResult<Visitor, ElementTypes>...>;
};
\end{lstlisting}

The following example program prints out the type produced by passing in a generic lambda that adds 1 to the value it gets:

\hspace*{\fill} \\ %插入空行
\noindent
\textit{variant/visit.cpp}
\begin{lstlisting}[style=styleCXX]
#include "variant.hpp"
#include <iostream>
#include <typeinfo>

int main()
{
	Variant<int, short, double, float> v(1.5);
	auto result = v.visit([](auto const& value) {
							return value + 1;
						});
	std::cout << typeid(result).name() << ’\n’;
}
\end{lstlisting}

The output of this program will be the type\_info name for double, because that is the type to which all of the result types can be converted.







